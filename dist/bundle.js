(()=>{"use strict";var r,e,n,t,o,a={434:(r,e,n)=>{n.d(e,{Z:()=>t});const t="body{background-color:#000;margin:0;padding:0}#c{display:none}canvas{display:block;position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}.container{display:flex;flex-direction:column;position:absolute;top:0;justify-content:center;align-items:center;width:100%;height:100%;color:#fff}p{font-size:100px;font-family:arial;text-align:center}.button{border-style:solid;padding:10px 20px;animation:blinkAnime .85714285714s infinite alternate}@keyframes blinkAnime{0%{border-color:#000}100%{border-color:#fff}}select{font-size:100px;font-family:arial;text-align:center}.lds-facebook{display:inline-block;position:relative;width:80px;height:80px}.lds-facebook div{display:inline-block;position:absolute;left:8px;width:16px;background:#fff;animation:lds-facebook 1.2s cubic-bezier(0,.5,.5,1) infinite}.lds-facebook div:nth-child(1){left:8px;animation-delay:-.24s}.lds-facebook div:nth-child(2){left:32px;animation-delay:-.12s}.lds-facebook div:nth-child(3){left:56px;animation-delay:0}@keyframes lds-facebook{0%{top:8px;height:64px}100%,50%{top:24px;height:32px}}"},370:(r,e,n)=>{n.d(e,{Z:()=>t});const t="void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    fragColor = vec4(tap4(iPrevPass, uv, texelSize), 1.0);\n}"},526:(r,e,n)=>{n.d(e,{Z:()=>t});const t="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomIntensity;  // 1 0 30\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iBeforeBloom, uv).rgb;\n    vec3 pair = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomIntensity * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},222:(r,e,n)=>{n.d(e,{Z:()=>t});const t="float brightness(vec3 c) { return max(max(c.r, c.g), c.b); }\n\nuniform float gBloomThreshold;  // 1.0 0 100 bloom\nuniform float gBloomSoftKnee;   // 0.5 0 4\n\n// https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Runtime/Components/BloomComponent.cs#L65-L67\n// https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Resources/Shaders/Bloom.shader#L86-L117\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float softKnee = gBloomSoftKnee;\n    float lthresh = gBloomThreshold;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iPrevPass, uv);\n    vec3 m = color.rgb;\n    float br = brightness(m);\n\n    float knee = lthresh * softKnee + 1e-5;\n    vec3 curve = vec3(lthresh - knee, knee * 2.0, 0.25 / knee);\n    float rq = clamp(br - curve.x, 0.0, curve.y);\n    rq = curve.z * rq * rq;\n\n    m *= max(rq, br - lthresh) / max(br, 1e-5);\n    m = max(m, vec3(0.0));\n\n    fragColor = vec4(m, color.a);\n}"},775:(r,e,n)=>{n.d(e,{Z:()=>t});const t="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomSpread;  // 1.3 1 2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomSpread * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},21:(r,e,n)=>{n.d(e,{Z:()=>t});const t="#version 300 es\n\ninvariant gl_Position;\nin vec2 vert2d;\n\nvoid main(void) { gl_Position = vec4(vert2d, 0, 1); }\n"},696:(r,e,n)=>{n.d(e,{Z:()=>t});const t="#version 300 es\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n\r\n// #define AA\r\n\r\nuniform vec3 iResolution;\r\nuniform float iTime;\r\nuniform sampler2D iChannel0; // first pass\r\nuniform sampler2D iPrevPass;\r\nuniform sampler2D iTextTexture;\r\n\r\n\r\nuniform float gCameraEyeX;     // -0.08828528243935951 -100 100 camera\r\nuniform float gCameraEyeY;     // 3.5309297601209235 -100 100\r\nuniform float gCameraEyeZ;     // -2.705631420983895 -100 100\r\nuniform float gCameraTargetX;  // 0.7576763789243015 -100 100\r\nuniform float gCameraTargetY;  // 3.4515422110479044 -100 100\r\nuniform float gCameraTargetZ;  // -0.21633410393024527 -100 100\r\nuniform float gCameraFov;      // 37.88049605411499 0 180\r\nuniform float gCameraDebug;    // 0 0 1\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\r\n\r\nout vec4 outColor;\r\nvoid main(void) {\r\n    vec4 c;\r\n#ifdef AA\r\n    vec4 t;\r\n    c = vec4(0.0);\r\n    for (int y = 0; y < 2; y++) {\r\n        for (int x = 0; x < 2; x++) {\r\n            vec2 sub = vec2(float(x), float(y)) * 0.5;  // FIXME\r\n            vec2 uv = gl_FragCoord.xy + sub;\r\n            mainImage(t, uv);\r\n            c += 0.25 * t;\r\n        }\r\n    }\r\n#else\r\n    mainImage(c, gl_FragCoord.xy);\r\n#endif\r\n    outColor = c;\r\n}\r\n\r\n/*\r\n\r\n// https://www.shadertoy.com/view/lsf3WH\r\n// Noise - value - 2D by iq\r\nfloat noise(vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n    vec2 u = f * f * (3.0 - 2.0 * f);\r\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), hash12(i + vec2(1.0, 0.0)), u.x), mix(hash12(i + vec2(0.0, 1.0)), hash12(i + vec2(1.0, 1.0)), u.x), u.y);\r\n}\r\n\r\nfloat fbm(vec2 uv) {\r\n    float f = 0.0;\r\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\r\n    f = 0.5000 * noise(uv);\r\n    uv = m * uv;\r\n    f += 0.2500 * noise(uv);\r\n    uv = m * uv;\r\n    f += 0.1250 * noise(uv);\r\n    uv = m * uv;\r\n    f += 0.0625 * noise(uv);\r\n    uv = m * uv;\r\n    return f;\r\n}\r\n\r\n*/\r\n\r\nvec3 tap4(sampler2D tex, vec2 uv, vec2 texelSize) {\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    vec3 s;\r\n    s = texture(tex, uv + d.xy).rgb;\r\n    s += texture(tex, uv + d.zy).rgb;\r\n    s += texture(tex, uv + d.xw).rgb;\r\n    s += texture(tex, uv + d.zw).rgb;\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\nvec2 textUv(vec2 uv, float id, vec2 p, float scale) {\r\n    uv -= p;\r\n    uv /= scale;\r\n\r\n    float offset = 128.0 / 4096.0;\r\n    float aspect = 2048.0 / 4096.0;\r\n    uv.x = 0.5 + 0.5 * uv.x;\r\n    uv.y = 0.5 - 0.5 * (aspect * uv.y + 1.0 - offset);\r\n    uv.y = clamp(uv.y + offset * id, offset * id, offset * (id + 1.0));\r\n\r\n    return uv;\r\n}\r\n"},905:(r,e,n)=>{n.d(e,{Z:()=>t});const t="uniform float gChromaticAberrationIntensity;  // 0.0003 0 0.1 post\r\nuniform float gChromaticAberrationDistance;   // 0.45 0 1\r\n\r\nuniform float gVignetteIntensity;   // 1.34 0 3\r\nuniform float gVignetteSmoothness;  // 2 0 5\r\nuniform float gVignetteRoundness;   // 1 0 1\r\n\r\nuniform float gTonemapExposure;  // 1 0.0 2\r\nuniform float gFlash;            // 0 0 1\r\nuniform float gFlashSpeed;       // 0 0 60\r\nuniform float gBlend;            // 0 -1 1\r\n\r\nuniform float gGlitchIntensity;  // 0 0 0.1\r\nuniform float gXSfhitGlitch;     // 0 0 0.1\r\nuniform float gInvertRate;       // 0 0 1\r\n\r\n/*\r\nvec3 chromaticAberration(vec2 uv) {\r\n    uv.x += gXSfhitGlitch * (fbm(vec2(232.0 * uv.y, beat)) - 0.5);\r\n\r\n    vec2 d = abs(uv - 0.5);\r\n    float f = mix(0.5, dot(d, d), gChromaticAberrationDistance);\r\n    f *= f * gChromaticAberrationIntensity;\r\n    vec2 shift = vec2(f);\r\n\r\n    float a = 2.0 * hash11(beat) - 1.0;\r\n    vec2 grid = hash23(vec3(floor(vec2(uv.x * (4.0 + 8.0 * a), (uv.y + a) * 32.0)), beat));\r\n    grid = 2.0 * grid - 1.0;\r\n    shift += gGlitchIntensity * grid;\r\n\r\n    vec3 col;\r\n    col.r = texture(iPrevPass, uv + shift).r;\r\n    col.g = texture(iPrevPass, uv).g;\r\n    col.b = texture(iPrevPass, uv - shift).b;\r\n    return col;\r\n}\r\n\r\nfloat vignette(vec2 uv) {\r\n    vec2 d = abs(uv - 0.5) * gVignetteIntensity;\r\n    float roundness = (1.0 - gVignetteRoundness) * 6.0 + gVignetteRoundness;\r\n    d = pow(d, vec2(roundness));\r\n    return pow(saturate(1.0 - dot(d, d)), gVignetteSmoothness);\r\n}\r\n\r\nvec3 acesFilm(const vec3 x) {\r\n    const float a = 2.51;\r\n    const float b = 0.03;\r\n    const float c = 2.43;\r\n    const float d = 0.59;\r\n    const float e = 0.14;\r\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\r\n}\r\n\r\nvec3 invert(vec3 c, vec2 uv) {\r\n    if (hash12(vec2(floor(uv.y * gInvertRate * 32.0), beat)) < gInvertRate) {\r\n        return vec3(1.0) - c;\r\n    } else {\r\n        return c;\r\n    }\r\n}\r\n\r\nvec3 flash(vec3 c) {\r\n    c = mix(c, vec3(1.0), gFlash * saturate(cos(iTime * PI * .5 * gFlashSpeed)));\r\n    return c;\r\n}\r\n\r\nvec3 blend(vec3 c) {\r\n    c = mix(c, vec3(1.0), saturate(gBlend));\r\n    c = mix(c, vec3(0.0), saturate(-gBlend));\r\n    return c;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    vec3 col = chromaticAberration(uv);\r\n    col *= vignette(uv);\r\n    col = acesFilm(col * gTonemapExposure);\r\n    col = pow(col, vec3(1.0 / 2.2));\r\n    col = invert(col, uv);\r\n    col = flash(col);\r\n    col = blend(col);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n\r\n*/\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    vec3 col = texture(iPrevPass, uv).rgb;\r\n    fragColor = vec4(col, 1.0);\r\n}"},681:(r,e,n)=>{n.d(e,{Z:()=>t});const t="const float TAU = 6.28318530718;\r\n#define BPM 120.0\r\n#define saturate(x) clamp(x, 0., 1.)\r\n#define tri(x) (1. - 4. * abs(fract(x) - .5))\r\n#define phase(x) (floor(x) + .5 + .5 * cos(TAU * .5 * exp(-5. * fract(x))))\r\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\r\n\r\n// Hash without Sine by David Hoskins.\r\n// https://www.shadertoy.com/view/4djSRW\r\nfloat hash11(float p) {\r\n    p = fract(p * .1031);\r\n    p *= p + 33.33;\r\n    p *= p + p;\r\n    return fract(p);\r\n}\r\n\r\nfloat hash12(vec2 p) {\r\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec2 hash23(vec3 p3) {\r\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n}\r\n\r\n// hemisphere hash function based on a hash by Slerpy\r\nvec3 hashHs(vec3 n, vec3 seed) {\r\n    vec2 h = hash23(seed);\r\n    float a = h.x * 2. - 1.;\r\n    float b = TAU * h.y * 2. - 1.;\r\n    float c = sqrt(1. - a * a);\r\n    vec3 r = vec3(c * cos(b), a, c * sin(b));\r\n    return r;\r\n}\r\n\r\n// global vars\r\nvec3 ro, target;\r\nfloat fov;\r\nvec3 scol;\r\nfloat beat, beatTau, beatPhase;\r\nvec3 boxPos;\r\n\r\n// Timeline\r\nfloat prevEndTime = 0., t = 0.;\r\n#define TL(end) if (t = beat - prevEndTime, beat < (prevEndTime = end))\r\n\r\n// Material Types\r\n#define VOL 0.\r\n#define SOL 1.\r\n\r\nvoid opUnion(inout vec4 m, float d, float type, float roughness_or_emissive, float hue) {\r\n    if (d < m.x) m = vec4(d, type, roughness_or_emissive, hue);\r\n}\r\n\r\nvec3 pal(vec4 m) {\r\n    // Integer part: Blend ratio with white (0-10)\r\n    // Decimal part: Hue (0-1)\r\n    vec3 col = vec3(.5) + .5 * cos(TAU * (vec3(0., .33, .67) + m.w));\r\n    return mix(col, vec3(.5), .1 * floor(m.w));\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\r\n}\r\n\r\nfloat sdBox(vec2 p, vec2 b) {\r\n    vec2 q = abs(p) - b;\r\n    return length(max(q, 0.)) + min(max(q.x, q.y), 0.);\r\n}\r\n\r\n// Hexagons - distance by iq\r\n// https://www.shadertoy.com/view/Xd2GR3\r\n// return: { 2d cell id (vec2), distance to border, distnace to center }\r\n#define INV_SQRT3 0.5773503\r\nvec4 hexagon(inout vec2 p) {\r\n    vec2 q = vec2(p.x * 2. * INV_SQRT3, p.y + p.x * INV_SQRT3);\r\n\r\n    vec2 pi = floor(q);\r\n    vec2 pf = fract(q);\r\n\r\n    float v = mod(pi.x + pi.y, 3.);\r\n\r\n    float ca = step(1., v);\r\n    float cb = step(2., v);\r\n    vec2 ma = step(pf.xy, pf.yx);\r\n\r\n    // distance to borders\r\n    float e = dot(ma, 1. - pf.yx + ca * (pf.x + pf.y - 1.) + cb * (pf.yx - 2. * pf.xy));\r\n\r\n    // distance to center\r\n    p = vec2(q.x + floor(.5 + p.y / 1.5), 4. * p.y / 3.) * .5 + .5;\r\n    p = (fract(p) - .5) * vec2(1., .85);\r\n    float f = length(p);\r\n\r\n    return vec4(pi + ca - cb * ma, e, f);\r\n}\r\n\r\nfloat warning(vec2 p) {\r\n    vec4 h = hexagon(p);\r\n\r\n    float f = fract(hash12(h.xy) + beatPhase);\r\n    f = mix(f, saturate(sin(h.x - h.y + 4. * beatPhase)), .5 + .5 * sin(beatTau / 16.));\r\n    float hex = smoothstep(.1, .11, h.z) * f;\r\n\r\n    float mark = 1.;\r\n    float dice = fract(hash12(h.xy) + beatPhase / 4.);\r\n\r\n    if (dice < .25) {\r\n        float d = sdBox(p, vec2(.4, dice));\r\n        float ph = phase(beat / 2. + f);\r\n        float ss = smoothstep(1., 1.05, mod(p.x * 10. + 10. * p.y + 8. * ph, 2.));\r\n        mark = saturate(step(0., d) + ss);\r\n    } else {\r\n        vec4[] param_array = vec4[](vec4(140., 72., 0., 0.), vec4(0., 184., 482, 0.), vec4(0., 0., 753., 0.), vec4(541., 156., 453., 0.), vec4(112., 0., 301., 0.),  // 0-3\r\n                                    vec4(311., 172., 50., 0.), vec4(249., 40., 492., 0.), vec4(0.), vec4(1.));                                                       // 4-7\r\n\r\n        vec4 param = param_array[int(mod(dice * 33.01, 8.))] / vec2(1200., 675.).xyxy;\r\n        // param = PU;\r\n        vec2 p1 = p - param.xy;\r\n        for (int i = 0; i < 3; i++) {\r\n            p1 = abs(p1 + param.xy) - param.xy;\r\n            rot(p1, TAU * param.z);\r\n        }\r\n\r\n        float d = sdBox(p1, vec2(.2, .05));\r\n        mark = saturate(smoothstep(0., .01, d));\r\n    }\r\n\r\n    return saturate(hex * mark);\r\n}\r\n\r\nvec4 map(vec3 pos, bool isFull) {\r\n    vec4 m = vec4(2, VOL, 0, 0);\r\n    // x: Distance\r\n    // y: MaterialType (VOL or SOL)\r\n    // z: Roughness in (0-1), Emissive when z>1\r\n    // w: ColorPalette\r\n\r\n    float roughness = 0.05;\r\n    float a = .1;\r\n    float W = 16.;\r\n    float H = 8.;\r\n    float D = 30.;\r\n\r\n    vec3 p1 = pos;\r\n\r\n    float boxEmi;\r\n\r\n    if (mod(beat, 8.) > 2. + step(56., beat) * 2.) {\r\n        boxEmi = 2.2 * saturate(sin(beatTau * 4.));\r\n    } else {\r\n        boxEmi = 2.2 * abs(cos((beatTau - p1.y) / 4.));\r\n    }\r\n\r\n    vec4 _IFS_Rot = vec4(0.34 + beatPhase / 2.3, -0.28, 0.03, 0.);\r\n    vec4 _IFS_Offset = vec4(1.36, 0.06, 0.69, 1.);\r\n    float _IFS_Iteration = phase(tri(beat / 16.) + 2.);\r\n    vec4 _IFS_BoxBase = vec4(1, 1, 1, 0);\r\n    vec4 _IFS_BoxEmissive = vec4(0.05, 1.05, 1.05, 0);\r\n\r\n    float hue = 0.5;\r\n    bool emi2 = false;\r\n\r\n    TL(40.) {\r\n        _IFS_Rot *= 0.;\r\n        _IFS_Offset *= 0.;\r\n        _IFS_Iteration = 1.;\r\n    }\r\n    else TL(56.) {\r\n        float fade = saturate(phase((beat - 56.) / 4.));\r\n        _IFS_Iteration = 1. + fade;\r\n        _IFS_Offset = vec4(1.36, 0.06, 0.69, 1.) * fade;\r\n    }\r\n    else TL(84.) {\r\n    }\r\n    else TL(96.) {\r\n        emi2 = true;\r\n    }\r\n    else TL(128.) {\r\n        emi2 = true;\r\n        hue = fract(.12 * beatPhase);\r\n    }\r\n    else TL(140.) {\r\n        emi2 = true;\r\n        hue = fract(beatPhase * .1 + pos.z) + 1.;\r\n        boxEmi *= 1.7;\r\n    }\r\n    else TL(152.) {\r\n        hue = 0.;\r\n    }\r\n    else TL(200.) {\r\n        emi2 = true;\r\n        hue = smoothstep(191., 192., beat) * 0.65;\r\n        _IFS_Iteration = 3. + phase(min(t / 4., 2.)) - phase(clamp((beat - 184.) / 4., 0., 2.));\r\n        _IFS_Rot = vec4(.3 + .1 * sin(beatPhase * TAU / 8.), .9 + .1 * sin(beatPhase * TAU / 8.), .4, 0.);\r\n        _IFS_Offset = vec4(1.4, 0.66, 1.2, 1.);\r\n    }\r\n    else TL(280.) {\r\n        emi2 = true;\r\n        hue = fract(beat * .12);\r\n        _IFS_Offset = vec4(2., 0.3, 0.3 + 0.3 * sin(beatTau / 8.), 1.);\r\n        _IFS_Rot = vec4(0.4 + phase(beat) / 2.3, -0.28 + phase(beat) / 2., 0.05, 0.);\r\n    }\r\n    else TL(296.) {\r\n    }\r\n    else TL(304.) {\r\n        emi2 = (beat < 296.);\r\n        _IFS_Iteration = 4. - phase(min(t / 8., 2.));\r\n    }\r\n    else TL(320.) {\r\n        float a = phase(saturate(t / 8.));\r\n        _IFS_Iteration = 2. - a;\r\n        _IFS_Rot *= (1. - a);\r\n        _IFS_Offset *= (1. - a);\r\n    }\r\n\r\n    p1 -= (boxPos + _IFS_Offset.xyz);\r\n\r\n    vec3 pp1 = p1;\r\n\r\n    for (int i = 0; i < int(_IFS_Iteration); i++) {\r\n        pp1 = p1 + _IFS_Offset.xyz;\r\n        p1 = abs(p1 + _IFS_Offset.xyz) - _IFS_Offset.xyz;\r\n        rot(p1.xz, TAU * _IFS_Rot.x);\r\n        rot(p1.zy, TAU * _IFS_Rot.y);\r\n        rot(p1.xy, TAU * _IFS_Rot.z);\r\n    }\r\n\r\n    vec4 mp = m;\r\n    opUnion(m, sdBox(p1, _IFS_BoxBase.xyz), SOL, roughness, 0.5);\r\n    opUnion(m, sdBox(p1, _IFS_BoxEmissive.xyz), SOL, roughness + boxEmi, hue);\r\n    if (emi2) opUnion(m, sdBox(p1, _IFS_BoxEmissive.yzx), SOL, roughness + boxEmi, hue + 0.5);\r\n    opUnion(mp, sdBox(pp1, _IFS_BoxBase.xyz), SOL, roughness, 0.5);\r\n    opUnion(mp, sdBox(pp1, _IFS_BoxEmissive.xyz), SOL, roughness + boxEmi, hue);\r\n    if (emi2) opUnion(mp, sdBox(pp1, _IFS_BoxEmissive.yzx), SOL, roughness + boxEmi, hue + 0.5);\r\n\r\n    m = mix(mp, m, fract(_IFS_Iteration));\r\n\r\n    // room\r\n    vec3 p2 = abs(pos);\r\n    float hole = sdBox(pos - vec3(0., -H - 0.5, 0.), vec3(1.1) * smoothstep(18., 24., beat));\r\n\r\n    // floor and ceil\r\n    opUnion(m, max(sdBox(p2 - vec3(0, H + 4., 0), vec3(W, 4., D)), -hole), SOL, roughness, 10.);\r\n\r\n    // door\r\n    float emi = step(p2.x, 2.) * step(p2.y, 2.);\r\n    if (mod(beat, 2.) < 1. && (beat < 48. || beat > 300.)) emi = 1. - emi;\r\n    opUnion(m, sdBox(p2 - vec3(0, 0, D + a), vec3(W, H, a)), SOL, roughness + emi * 2., 10.0);\r\n\r\n    // wall\r\n    if (isFull) {\r\n        float id = floor((pos.z + D) / 4.);\r\n        hue = 10.;\r\n\r\n        TL(18.) { emi = step(1., mod(id, 2.)) * step(id, mod(beat * 4., 16.)); }\r\n        else TL(32.) {\r\n            emi = step(1., mod(id, 2.));\r\n        }\r\n        else TL(126.) {\r\n            emi = step(1., mod(id, 2.)) * step(id, mod(beat * 4., 16.));\r\n            emi = mix(emi, step(.5, hash12(floor(pos.yz) + 123.23 * floor(beat * 2.))), saturate(beat - 112. - pos.y));\r\n        }\r\n        else TL(140.) {\r\n            emi = step(.5, hash12(floor(pos.yz) + 123.23 * floor(beat * 2.)));\r\n        }\r\n        else TL(202.) {\r\n            hue = 0.;\r\n            float fade1 = smoothstep(140., 144., beat);\r\n            float fade2 = smoothstep(200., 202., beat);\r\n            float pw = mix(10., 0.6, fade1);\r\n            pw = mix(pw, 20., fade2);\r\n            emi = pow(warning(pos.zy / 2.), pw) * mix(1., step(0., sin(t * 15. * TAU)), fade1 * fade2);\r\n            emi = step(0.5, emi) * emi * 1.05;\r\n        }\r\n        else TL(224.) {\r\n            emi = pow(hash12(floor(pos.yz) + 123.23 * floor(beat * 2.)), 4.) * smoothstep(0., 4., t);\r\n            hue = 3.65;\r\n        }\r\n        else TL(280.) {\r\n            float fade1 = smoothstep(276., 280., beat);\r\n            float fade2 = smoothstep(274., 280., beat);\r\n\r\n            emi = pow(hash12(floor(pos.yz * mix(1., 16., fade1)) + 123.23 * floor(beat * 2.)), 4.);\r\n            emi = mix(emi, step(.0, emi) * step(3., mod(floor((pos.z + D) / 2.), 4.)), fade1);\r\n\r\n            hue = hash12(floor(pos.yz) + 123.23 * floor(beat * 8.));\r\n            hue = mix(hue, 10., fade2);\r\n        }\r\n        else TL(320.) {\r\n            emi = step(3., mod(floor((pos.z + D) / 2.), 4.)) * step(1., mod(floor(pos.y - pos.z - 4. * beatPhase), 2.));\r\n        }\r\n    }\r\n\r\n    opUnion(m, sdBox(p2 - vec3(W + a, 0, 0), vec3(a, H, D)), SOL, roughness + emi * 2., hue);\r\n\r\n    return m;\r\n}\r\n\r\nvec3 normal(vec3 p) {\r\n    vec2 e = vec2(0, .05);\r\n    return normalize(map(p, false).x - vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));\r\n}\r\n\r\n// Based on EOT - Grid scene by Virgill\r\n// https://www.shadertoy.com/view/Xt3cWS\r\nvoid madtracer(vec3 ro1, vec3 rd1, float seed) {\r\n    scol = vec3(0);\r\n    vec2 rand = hash23(vec3(seed, iTime, iTime)) * .5;\r\n    float t = rand.x, t2 = rand.y;\r\n    vec4 m1, m2;\r\n    vec3 rd2, ro2, nor2;\r\n    for (int i = 0; i < 130; i++) {\r\n        m1 = map(ro1 + rd1 * t, true);\r\n        // t += m1.y == VOL ? 0.25 * abs(m1.x) + 0.0008 : 0.25 * m1.x;\r\n        t += 0.25 * mix(abs(m1.x) + 0.0032, m1.x, m1.y);\r\n        ro2 = ro1 + rd1 * t;\r\n        nor2 = normal(ro2);\r\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, vec3(seed, i, iTime)), saturate(m1.z));\r\n        m2 = map(ro2 + rd2 * t2, true);\r\n        // t2 += m2.y == VOL ? 0.15 * abs(m2.x) : 0.15 * m2.x;\r\n        t2 += 0.15 * mix(abs(m2.x), m2.x, m2.y);\r\n        scol += .015 * (pal(m2) * max(0., m2.z - 1.) + pal(m1) * max(0., m1.z - 1.));\r\n\r\n        // force disable unroll for WebGL 1.0\r\n        if (t < -1.) break;\r\n    }\r\n}\r\n\r\nvoid raymarching(vec3 ro1, vec3 rd1) {\r\n    scol = vec3(0);\r\n    float t = 0.;\r\n    vec4 m;\r\n    for (int i = 0; i < 160; i++) {\r\n        vec3 p = ro1 + rd1 * t;\r\n        m = map(p, true);\r\n        t += m.x;\r\n\r\n        if (m.x < 0.01) {\r\n            vec3 light = normalize(vec3(1, 1, -1));\r\n            vec3 albedo = vec3(0.3);\r\n            if (m.z > 1.) albedo = pal(m);\r\n            scol = albedo * (0.5 + 0.5 * saturate(dot(normal(p), light)));\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\r\n    beat = iTime * BPM / 60.0;\r\n    beatTau = beat * TAU;\r\n    beatPhase = phase(beat / 2.);\r\n\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n\r\n    boxPos = vec3(0);\r\n    boxPos.y = mix(-12., 0., smoothstep(20., 48., beat));\r\n    boxPos.y = mix(boxPos.y, -12., smoothstep(304., 320., beat));\r\n\r\n    // Camera\r\n    vec2 noise = hash23(vec3(iTime, fragCoord)) - .5;  // AA\r\n    vec2 uv2 = (2. * (fragCoord.xy + noise) - iResolution.xy) / iResolution.x;\r\n\r\n    // 通常時カメラ\r\n    float dice = hash11(floor(beat / 8. + 2.) * 123.);\r\n    if (dice < .8)\r\n        ro = vec3(8. * cos(beatTau / 128.), mix(-6., 6., dice), 8. * sin(beatTau / 128.));\r\n    else\r\n        ro = vec3(9.5 - dice * 20., 1., -12.3);\r\n\r\n    target = boxPos;\r\n    fov = 120.;\r\n\r\n    // Timeline\r\n    TL(8.) {\r\n        ro = vec3(0, -1.36, -12.3 + t * .3);\r\n        target = vec3(0., -2.2, 0.);\r\n        fov = 100.;\r\n    }\r\n    else TL(16.) {\r\n        ro = vec3(9.5, -1.36, -12.3 + t * .3);\r\n        target = vec3(0., -2.2, 0.);\r\n        fov = 100.;\r\n    }\r\n    else TL(20.) {\r\n        ro = vec3(5.5, -5, -1.2);\r\n        target = vec3(0., -8., -0.);\r\n        fov = 100.0 + t;\r\n    }\r\n    else TL(32.) {\r\n        ro = vec3(5.5, -5, -1.2);\r\n        target = vec3(0., -8., -0.);\r\n        fov = 60.0 + t;\r\n    }\r\n    else TL(40.) {\r\n        ro = vec3(10.8, -4.2, -7.2 + t * .1);\r\n        fov = 93.;\r\n    }\r\n    else TL(64.) {\r\n        ro = vec3(0., 1., -12.3);\r\n        target = vec3(0);\r\n        fov = 100. - t;\r\n    }\r\n    else TL(80.) {\r\n        ro = vec3(8. * cos(beatTau / 128.), 1., 8. * sin(beatTau / 128.));\r\n        fov = 80.;\r\n    }\r\n    else TL(104.) {\r\n    }\r\n    else TL(110.) {\r\n        ro = vec3(-5., 1., 18.);\r\n        target = vec3(5.0, -1., 16.);\r\n        fov = 100. - t;\r\n    }\r\n    else TL(124.) {\r\n    }\r\n    else TL(130.) {\r\n        ro = vec3(0., 1., -12.3);\r\n        fov = 70. - t;\r\n    }\r\n    else TL(138.) {\r\n    }\r\n    else TL(148.) {\r\n        ro = vec3(-5., 1., 18.);\r\n        target = vec3(5.0, -1., 16.);\r\n        fov = 100. - t;\r\n    }\r\n    else TL(160.) {\r\n        ro *= 1.6;\r\n    }\r\n    else TL(178.) {\r\n        ro = vec3(0, 0, 7. + t / 4.);\r\n    }\r\n    else TL(198.) {\r\n        ro = vec3(8. * cos(beatTau / 128.), -3. + t / 4., 8. * sin(beatTau / 128.));\r\n    }\r\n    else TL(208.) {\r\n        ro = vec3(-5., 1., 18.);\r\n        target = vec3(5.0, -1., 16.);\r\n        fov = 100. - t;\r\n    }\r\n    else TL(274.) {\r\n    }\r\n    else TL(284.) {\r\n        ro = vec3(-5., 1., 18.);\r\n        target = vec3(5.0, -1., 16.);\r\n        fov = 100. - t;\r\n    }\r\n    else TL(304.) {\r\n    }\r\n    else TL(320.) {\r\n        ro = vec3(0., 1., -12.3);\r\n        target = vec3(0);\r\n        fov = 90. + t;\r\n    }\r\n\r\n#ifdef DEBUG_CAMERA\r\n    if (gCameraDebug > 0.) {\r\n        ro = vec3(gCameraEyeX, gCameraEyeY, gCameraEyeZ);\r\n        target = vec3(gCameraTargetX, gCameraTargetY, gCameraTargetZ);\r\n        fov = gCameraFov;\r\n    }\r\n#endif\r\n\r\n    vec3 up = vec3(0, 1, 0);\r\n    vec3 fwd = normalize(target - ro);\r\n    vec3 right = normalize(cross(up, fwd));\r\n    up = normalize(cross(fwd, right));\r\n    vec3 rd = normalize(right * uv2.x + up * uv2.y + fwd / tan(fov * TAU / 720.));\r\n\r\n// #define DEBUG_SCENE\r\n#ifdef DEBUG_SCENE\r\n    raymarching(ro, rd);\r\n    fragColor = vec4(scol, 1.);\r\n#else\r\n    madtracer(ro, rd, hash12(uv2));\r\n    vec3 bufa = texture(iChannel0, uv).xyz;\r\n\r\n    // fade out\r\n    scol = mix(scol, vec3(0), smoothstep(316., 320., beat));\r\n    fragColor = saturate(vec4(0.7 * scol + 0.7 * bufa, 1.));\r\n#endif\r\n}"},405:(r,e,n)=>{n.d(e,{Z:()=>t});const t='#version 300 es\r\nprecision mediump float;\r\nuniform float iSampleRate;\r\nuniform float iBlockOffset;\r\n\r\nvec2 mainSound(int samp, float time);\r\n\r\nout vec4 outColor;\r\nvoid main() {\r\n    float t = iBlockOffset + ((gl_FragCoord.x - 0.5) + (gl_FragCoord.y - 0.5) * 512.0) / iSampleRate;\r\n    vec2 y = mainSound(int(iSampleRate), t);\r\n    vec2 v = floor((0.5 + 0.5 * y) * 65536.0);\r\n    vec2 vl = mod(v, 256.0) / 255.0;\r\n    vec2 vh = floor(v / 256.0) / 255.0;\r\n    outColor = vec4(vl.x, vh.x, vl.y, vh.y);\r\n}\r\n\r\n//--------------------\r\n// ここから下を書き換える\r\n//--------------------\r\n\r\n// The code below is split into several parts.\r\n// UTILS - Constants and hash functions and stuff\r\n// WAVEFORMS - Basic noise and tone generators\r\n// INSTRUMENTS - Stuff that makes notes\r\n// PHRASES AND SONG PARTS - What to play, how to play it, up to the final mix.\r\n\r\n\r\n///////////////////////////////\r\n/////////// UTILS /////////////\r\n///////////////////////////////\r\n\r\n#define TAU (2.*3.1415926)\r\n// Convert MIDI note number to cycles per second\r\n#define midicps(n) (440.*exp(log(2.)*(n-69.)/12.))\r\n\r\nfloat rand(float p)\r\n{\r\n    // Hash function by Dave Hoskins\r\n    // https://www.shadertoy.com/view/4djSRW\r\n    p = fract(p * .1031);\r\n    p *= p + 33.33;\r\n    p *= p + p;\r\n    return fract(p);\r\n}\r\n\r\nvec2 rand2(float p)\r\n{\r\n    // Hash function by Dave Hoskins\r\n    // https://www.shadertoy.com/view/4djSRW\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\n\r\n////////////////////////////////////\r\n/////////// WAVEFORMS //////////////\r\n////////////////////////////////////\r\n\r\nfloat noise(float s){\r\n    // Noise is sampled at every integer s\r\n    // If s = t*f, the resulting signal is close to a white noise\r\n    // with a sharp cutoff at frequency f.\r\n    \r\n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\r\n    // and the former produces fewer artifacts?\r\n    int si = int(floor(s));\r\n    float sf = fract(s);\r\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\r\n    //sf = sf*sf*sf*(sf*(sf*6.0-15.0)+10.0); // quintic curve\r\n    // see https://iquilezles.org/articles/texture\r\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\r\n}\r\n\r\nvec2 noise2(float s){\r\n    int si = int(floor(s));\r\n    float sf = fract(s);\r\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\r\n    return mix(rand2(float(si)), rand2(float(si+1)), sf) * 2. - 1.;\r\n}\r\n\r\n\r\nfloat coloredNoise(float t, float fc, float df)\r\n{\r\n    // Noise peak centered around frequency fc\r\n    // containing frequencies between fc-df and fc+df\r\n    \r\n    // Assumes fc is an integer, to avoid problems with sin(large number).\r\n    \r\n    // Modulate df-wide noise by an fc-frequency sinusoid\r\n    //float n1 = noise(t*df);\r\n    //float n2 = noise(t*df - 100000.);\r\n    //vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\r\n    return sin(TAU*fc*fract(t))*noise(t*df);\r\n}\r\n\r\nvec2 coloredNoise2(float t, float fc, float df)\r\n{\r\n    // Noise peak centered around frequency fc\r\n    // containing frequencies between fc-df and fc+df\r\n    vec2 noiz = noise2(t*df);\r\n    vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\r\n    return modul*noiz;\r\n}\r\n\r\n\r\nfloat window(float a, float b, float t)\r\n{\r\n    return smoothstep(a, (a+b)*0.5, t) * smoothstep(b, (a+b)*0.5, t);\r\n}\r\n\r\nfloat formantSin(float phase, float form)\r\n{\r\n    // Inspired by the wavetable "formant" option\r\n    // in software synthesizer Surge (super cool freeware synth!)\r\n    phase = fract(phase);\r\n    phase = min(phase*form, 1.);\r\n    return sin(TAU*phase);\r\n}\r\nvec2 formantSin2(vec2 phase, vec2 form)\r\n{\r\n    // Inspired by the wavetable "formant" option\r\n    // in software synthesizer Surge (super cool freeware synth!)\r\n    phase = fract(phase);\r\n    phase = min(phase*form, 1.);\r\n    return sin(TAU*phase);\r\n}\r\n\r\n\r\nfloat lpfSaw(float t, float f, float fc, float Q)\r\n{\r\n    // Low-pass-filtered sawtooth wave\r\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\r\n    float omega_c = 2.*3.14159*fc/f; // relative\r\n    t = f*t - floor(f*t);\r\n    // Compute the exact response of a second order system with those parameters\r\n    // (value and derivative are continuous)\r\n    // It is expressed as\r\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\r\n    // We need to compute the amplitude A and phase phi.\r\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\r\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\r\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\r\n    float phi = atan(tanphi);\r\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\r\n    \r\n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\r\n    return v;\r\n}\r\n\r\nvec2 lpfSaw(float t, vec2 f, float fc, float Q)\r\n{\r\n    // Low-pass-filtered sawtooth wave\r\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\r\n    vec2 omega_c = 2.*3.14159*fc/f; // relative\r\n    vec2 t2 = f*t - floor(f*t);\r\n    // Compute the exact response of a second order system with those parameters\r\n    // (value and derivative are continuous)\r\n    // It is expressed as\r\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\r\n    // We need to compute the amplitude A and phase phi.\r\n    vec2 alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\r\n    vec2 tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\r\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\r\n    vec2 phi = atan(tanphi);\r\n    vec2 A = -2./(cos(phi) - beta*cos(omega_c+phi));\r\n    \r\n    vec2 v = 1.-2.*t2 + A*exp(-alpha*t2) * cos(omega_c*t2+phi);\r\n    return v;\r\n}\r\n\r\n\r\n///////////////////////////////////\r\n//////// INSTRUMENTS //////////////\r\n///////////////////////////////////\r\n\r\nvec2 hat1(float t)\r\n{\r\n    // Smooth hi-hat, almost shaker-like\r\n    return coloredNoise2(t, 10000., 5000.) * smoothstep(0.,0.02,t) * smoothstep(0.06,0.01,t) * 0.1;\r\n}\r\n\r\nvec2 hat2(float t, float fc)\r\n{\r\n    // Short hi-hat with tuneable center frequency\r\n    return coloredNoise2(t, fc, fc-1000.) * smoothstep(0.,0.001,t) * smoothstep(0.03,0.01,t) * 0.1;\r\n}\r\n\r\nvec2 snare1(float t)\r\n{\r\n    // Composite snare\r\n    float body = (sin(TAU*t*250.) + sin(TAU*t*320.)) * smoothstep(0.1,0.0,t) * 1.;\r\n    vec2 timbre = coloredNoise2(t, 1000., 7000.) * exp(-12.*t) * smoothstep(0.5,0.,t) * 8.;\r\n    vec2 sig = (body+timbre) * smoothstep(0.,0.001,t);\r\n    sig = sig/(1.+abs(sig)); // distort\r\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\r\n    return sig * 0.1;\r\n}\r\n\r\nvec2 snare2(float t)\r\n{\r\n    // Basic noise-based snare\r\n    float noi = coloredNoise(t, 4000., 1000.) + coloredNoise(t, 4000., 3800.) + coloredNoise(t,8000.,7500.) * 0.5;\r\n    float env = smoothstep(0.,0.001,t) * smoothstep(0.2,0.05,t);\r\n    env *= (1. + smoothstep(0.02,0.0,t)); // increase transient\r\n    env *= (1. - 0.5*window(0.02,0.1,t)); // fake compression\r\n    vec2 sig = vec2(noi) * env;\r\n    sig = sig/(1.+abs(sig));\r\n    return sig * 0.1;\r\n}\r\n\r\nfloat kick1(float t)\r\n{\r\n    // Composite kick\r\n    \r\n    // Kick is composed of a decaying sine tone, and a burst of noise,\r\n    // all of it distorted and shaped with a nice envelope.\r\n    \r\n    // frequency is assumed to be f0 + df*exp(-t/dftime);\r\n    float f0 = 50., df=500., dftime=0.02;\r\n    float phase = TAU * (f0*t - df*dftime*exp(-t/dftime));\r\n    float body = sin(phase) * smoothstep(0.15,0.,t) * 2.;\r\n    float click = coloredNoise(t, 8000., 2000.) * smoothstep(0.01,0.0,t);\r\n    //float boom = sin(f0*TAU*t) * smoothstep(0.,0.02,t) * smoothstep(0.15,0.,t);\r\n    float sig = body + click;\r\n    sig = sig/(1.+abs(sig));\r\n    //sig += boom;\r\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\r\n    sig *= (1. + window(0.05,0.15,t)); // increase tail\r\n    return sig * 0.2;\r\n}\r\n\r\nvec2 bass1(float t, float f, float cutoff)\r\n{\r\n    // Composite bass\r\n    // (I\'m very happy about this one!)\r\n    \r\n    // "Cutoff" is not actually the cutoff frequency of a filter,\r\n    // but it controls the amount of high frequencies\r\n    // we bring in using the "formantSin" waveform.\r\n    cutoff *= exp(-t*5.);\r\n    float formant = max(cutoff/f, 1.);\r\n    // Pure sine tone\r\n    float funda = sin(TAU*f*t);\r\n    // Phase-modulated sine gives more "body" to the sound\r\n    float body = sin(2.*TAU*f*t + (0.2*formant)*sin(TAU*f*t));\r\n    // Gritty attack using a truncated sinusoid waveform\r\n    // (dephased for stereo effect)\r\n    vec2 highs = formantSin2(f*t + vec2(0,0.5), vec2(formant)) * exp(-t*10.);\r\n    vec2 sig = body + highs + funda;\r\n    // Two-rate envelope with a strong transient and long decay\r\n    sig *= (2.*exp(-t*20.) + exp(-t*2.));\r\n    sig *= (1. + 0.3*smoothstep(0.05,0.0,t)); // increase transient\r\n    \r\n    // Finally, add some distortion\r\n    //sig = sig / (1. + abs(sig)); // Feel free to try how this one sounds.\r\n    sig = sin(sig); // This one gives lovely sidebands when pushed hard.\r\n    return sig * 0.1;\r\n}\r\n\r\nvec2 pad1(float t, vec4 f, float fc, float Q)\r\n{\r\n    // Filtered sawtooth-based pad, playing four-note chords\r\n    \r\n    // f: frequencies of the four notes\r\n    // fc, Q: cutoff frequency and quality factor of the 12dB/octave lowpass filter\r\n    vec2 sig = vec2(0);\r\n    sig += lpfSaw(t, f.x+vec2(-2,2), fc, Q);\r\n    sig += lpfSaw(t, f.y+vec2(1.7,-1.7), fc, Q);\r\n    sig += lpfSaw(t, f.z+vec2(-0.5,0.5), fc, Q);\r\n    sig += lpfSaw(t, f.w+vec2(1.5,-1.5), fc, Q);\r\n    return sig * 0.02;\r\n}\r\n\r\nvec2 arp1(float t, vec4 f, float fc, float dur)\r\n{\r\n    // Plucky arpeggiator, playing 16th notes.\r\n    \r\n    // dur: decay time of the notes (amplitude and filter)\r\n    vec2 sig = vec2(0);\r\n    vec4 ts = mod(t-vec4(0,0.125,0.25,0.375), 0.5);\r\n    sig += lpfSaw(t, f.x, fc*exp(-ts.x/dur), 10.) * smoothstep(0.0,0.01,ts.x) * exp(-ts.x/dur);\r\n    sig += lpfSaw(t, f.y, fc*exp(-ts.y/dur), 10.) * smoothstep(0.0,0.01,ts.y) * exp(-ts.y/dur);\r\n    sig += lpfSaw(t, f.z, fc*exp(-ts.z/dur), 10.) * smoothstep(0.0,0.01,ts.z) * exp(-ts.z/dur);\r\n    sig += lpfSaw(t, f.w, fc*exp(-ts.w/dur), 10.) * smoothstep(0.0,0.01,ts.w) * exp(-ts.w/dur);\r\n    return sig * 0.04;\r\n}\r\n\r\nvec2 marimba1(float t, float f)\r\n{\r\n    // Simple phase-modulation based marimba\r\n    \r\n    vec2 sig = vec2(0);\r\n    // Super basic marimba sound\r\n    sig += sin(TAU*f*t + exp(-50.*t)*sin(TAU*7.*f*t)) * exp(-5.*t) * step(0.,t);\r\n    // Fake reverb effect: long-decay, stereo-detuned fundamental\r\n    sig += sin(TAU*(f+vec2(-2,2))*t) * exp(-1.5*t) * 0.5;\r\n    return vec2(sig) * 0.05;\r\n}\r\n\r\nvec2 pad2(float t, vec4 f, float fres)\r\n{\r\n    // Four-note, phase-modulation-based pad.\r\n    \r\n    // fres: center frequency of the faked "spectral aliasing"\r\n    \r\n    vec2 sig = vec2(0);\r\n    // Index of modulation\r\n    // https://en.wikipedia.org/wiki/Frequency_modulation#Modulation_index\r\n    vec4 iom1 = 2.+0.5*sin(t + vec4(0,1,2,3));\r\n    // Play an octave lower than asked\r\n    f *= 0.5;\r\n    // Modulator has frequency 2f -> odd harmonics only\r\n    sig += sin(TAU*t*f.x + iom1.x * sin(2.*TAU*t*(f.x+vec2(-1,1)))) * vec2(1,0);\r\n    sig += sin(TAU*t*f.y + iom1.y * sin(2.*TAU*t*(f.y+vec2(-1.2,0.8)))) * vec2(0.7,0.3);\r\n    sig += sin(TAU*t*f.z + iom1.z * sin(2.*TAU*t*(f.z+vec2(-0.5,1.5)))) * vec2(0.3,0.7);\r\n    sig += sin(TAU*t*f.w + iom1.w * sin(2.*TAU*t*(f.w+vec2(-1.3,0.7)))) * vec2(0,1);\r\n    \r\n    // Fake spectral aliasing, to add some high-end\r\n    vec2 warped = vec2(0);\r\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.x)) * vec2(1,0);\r\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.y)) * vec2(0.7,0.3);\r\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.z)) * vec2(0.3,0.7);\r\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.w)) * vec2(0,1);\r\n    \r\n    // Mix to taste\r\n    sig = (sig + 0.01*warped) * 0.02;\r\n    // Reduce stereo image\r\n    sig = mix(sig.xy, sig.yx, 0.1);\r\n    return sig;\r\n}\r\n\r\n\r\n////////////////////////////////////////////\r\n/////// PHRASES AND SONG PARTS /////////////\r\n////////////////////////////////////////////\r\n\r\n\r\nfloat leadphrasenote(float t)\r\n{\r\n    // Four-bar lead synth phrase in the final chorus\r\n    // MIDI note number (or 0. if silence)\r\n    float note =\r\n        (t<0.5) ? 69. : (t<1.) ? 71. : (t<1.5) ? 72. : (t<1.75) ? 76. :\r\n        (t<3.0) ? 74. : (t<3.25) ? 0. : (t<3.5) ? 72. : (t<3.75) ? 74. :\r\n        (t<5.5) ? 76. : (t<5.75) ? 79. : (t<7.5) ? 71. : 0.;\r\n    return note;\r\n}\r\n\r\nvec2 leadphrase1(float t, float fc)\r\n{\r\n    // Four-bar lead synth phrase in the final chorus\r\n    \r\n    float note = leadphrasenote(t);\r\n    // Add some vibrato\r\n    float vibStrength = window(2.,3.,t) + window(4.,5.5,t) + window(6.,8.,t);\r\n    float f = midicps(note + vibStrength*0.01*sin(5.*TAU*t)/(t+0.1));\r\n    // Cut silence\r\n    float env = (note > 0.) ? 1. : 0.;\r\n    \r\n    // "Super-saw" lead\r\n    vec2 sig = lpfSaw(t, f+vec2(-2,2), fc, 1.);\r\n    sig += lpfSaw(t, f+vec2(3.2,-3.2), fc, 1.);\r\n    sig += lpfSaw(t, f, fc, 1.);\r\n    \r\n    // Distort\r\n    sig *= 2.;\r\n    sig = sig/(1.+abs(sig));\r\n    \r\n    return sig * 0.05 * env;\r\n}\r\n\r\nvec2 leadchorus(float t, float fc)\r\n{\r\n    // Four-bar lead synth phrase in the final chorus\r\n    // Add delay effect\r\n    vec2 sig = leadphrase1(t, fc);\r\n    sig = mix(sig, sig.yx, 0.3);\r\n    sig += leadphrase1(mod(t-0.25,8.), fc*0.7).yx * vec2(0.5,-0.5);\r\n    sig += leadphrase1(mod(t-1., 8.), 1000.) * 0.5;\r\n    return sig;\r\n}\r\n\r\nvec2 basschorus(float t, float fc)\r\n{\r\n    // Bass of the final chorus:\r\n    // Simply play the fundamental of each bar, with octave jumps\r\n    \r\n    // Every second 8th note is an octave above\r\n    float octave = 12.*step(0.25,mod(t,0.5));\r\n    // Fundamental of each of the four bars\r\n    float note = (t<2.) ? 69.-36.+octave : \r\n                 (t<4.) ? 62.-36.+octave :\r\n                 (t<6.) ? 60.-36.+octave :\r\n                 67.-36.+octave;\r\n    \r\n    float t1 = mod(t, 0.25);\r\n    vec2 sig = bass1(t1, midicps(note), fc);\r\n    \r\n    return sig;\r\n}\r\n\r\nvec2 padchorus(float t, float fc, float Q)\r\n{\r\n    // Pad part for the final chorus\r\n    // Simply play the (slightly rich) chords\r\n    // ||: Am(add9) | Dm7 | C(add9) | G(add9) :||\r\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\r\n    \r\n    vec2 pad = pad1(t, midicps(chord), fc, Q);\r\n    return pad;\r\n}\r\n\r\n\r\nvec2 arpchorus(float t, float fc, float dur)\r\n{\r\n    // Arpeggiator part for the final chorus\r\n    // Simply arpeggiate the four chords\r\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\r\n    vec2 arp = arp1(t, midicps(chord+12.), fc, dur);\r\n    return arp;\r\n}\r\n\r\n\r\nvec2 fullChorus(float time)\r\n{\r\n    // Full mix for the final chorus\r\n    time = mod(time, 8.);\r\n    vec2 v = vec2(0);\r\n    \r\n    // Percussions (with a slight 16th-note swing)\r\n    v += hat1(mod(time, 0.25)) * vec2(0.8,1.0);\r\n    v += hat1(mod(time-0.14, 0.25)) * vec2(0.3,-0.2);\r\n    v += snare1(mod(time-0.5, 1.));\r\n    v += kick1(mod(time, 0.5));\r\n    \r\n    // Low-frequency oscillator on a macro control\r\n    float cutoff = 300. + 200.*sin(time);\r\n    \r\n    float t = mod(time, 0.5);\r\n    // Another LFO for fake sidechain compression ("pumping" effect)\r\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\r\n    \r\n    v += basschorus(mod(time,8.), cutoff) *mix(pumping, 1.,0.3);\r\n    \r\n    vec2 pads = padchorus(mod(time, 8.), 8000.-1000.*sin(time), 2.);\r\n    pads *= mix(pumping, 1., 0.1);\r\n    v += pads;\r\n    \r\n    // A third LFO to vary the note length of the arpeggiator\r\n    float dur = 0.2 * exp(0.2*sin(time*0.6));\r\n    vec2 arp = arpchorus(mod(time, 8.), 5000.-1000.*cos(0.7*time), dur);\r\n    v += arp * mix(pumping, 1.,0.2);\r\n    \r\n    v += leadchorus(mod(time,8.), 10000.) * mix(pumping,1.,0.5);\r\n    \r\n    return v;\r\n}\r\n\r\nvec2 padPhraseVerse(float time, float fc)\r\n{\r\n    // Pad during the verse: play three chords in four bars\r\n    // ||: Am(add11) | FMaj7 | Em7 | Em7 :||\r\n    float t = mod(time, 8.);\r\n    vec4 chord = (t<2.) ? vec4(57,60,62,64) : (t<4.) ? vec4(53,57,60,64) : vec4(52,55,62,64);\r\n    // Smoothe out the transitions from one chord to the next,\r\n    // as they are not masked by percussion.\r\n    float env = 1. - window(-0.1,0.1,t) - window(1.9,2.1,t) - window(3.9,4.1,t) - window(7.9,8.1,t);\r\n    // Add some movement with volume automation\r\n    env *= 1. + 0.2*window(0.25,0.5,mod(t,0.5));\r\n    return pad1(t, midicps(chord), fc*0.7, 2.) * env;\r\n}\r\n\r\nvec2 padVerse(float time, float fc)\r\n{\r\n    // Verse pad with delay effect\r\n    return padPhraseVerse(time, fc) + 0.5*padPhraseVerse(time-0.5,fc).yx + 0.2*padPhraseVerse(time-1.5,fc);\r\n}\r\n\r\nvec2 marimbaVerse(float t, float fc)\r\n{\r\n    // Marimba part for the verse:\r\n    // just a few notes, always the same.\r\n    vec2 v = vec2(0);\r\n    v += marimba1(mod(t-0.00,8.), midicps(72.));\r\n    v += marimba1(mod(t-0.75,8.), midicps(71.));\r\n    v += marimba1(mod(t-1.50,8.), midicps(69.));\r\n    v += marimba1(mod(t-2.25,8.), midicps(64.));\r\n    v += marimba1(mod(t-7.50,8.), midicps(69.));\r\n    v += marimba1(mod(t-7.75,8.), midicps(71.));\r\n    return v;\r\n}\r\n\r\nvec2 arpVerse(float time, float fc, float dur)\r\n{\r\n    // Verse arpeggiator: just arpeggiate the chords\r\n    // (different notes than the pad this time).\r\n    // Cutoff frequency and note duration will be varied for tension.\r\n    float t = mod(time, 8.);\r\n    vec4 chord = (t<2.) ? vec4(57,64,69,71) : (t<4.) ? vec4(57,64,65,72) : vec4(59,64,69,74);\r\n    return arp1(t, midicps(chord), fc, dur);\r\n}\r\n\r\nvec2 fullVerse(float time)\r\n{\r\n    vec2 v = vec2(0);\r\n    // Cutoff frequency: dark sound initially,\r\n    // but with a riser in the last four bars.\r\n    float fc = 400. - 100.*cos(time) + 10000. * pow(clamp((time-24.)/(32.-24.),0.,1.), 4.);\r\n    v += padVerse(time, fc) * 0.5;\r\n    v += marimbaVerse(time, fc);\r\n    if(time > 16.)\r\n    {\r\n        // Arpeggiator comes in after 8 bars, and note duration increases\r\n        // during the riser.\r\n        float dur = mix(0.05,0.5, smoothstep(24.,32.,time));\r\n        v += arpVerse(time, fc, dur) * smoothstep(16.,18.,time);\r\n    }\r\n    return v;\r\n}\r\n\r\nvec2 bassDrop1(float time)\r\n{\r\n    // Groovy four-bar phrase of the bass during the drop.\r\n    \r\n    // (In fact, it is the only part of this song with\r\n    // some melodic/rhythmic complexity and variation.\r\n    // The rest is extremely mechanical.)\r\n    \r\n    vec2 v = vec2(0);\r\n    \r\n    time = mod(time, 8.);\r\n    \r\n    float sx = floor(time / 0.125); // sixteenth note number\r\n    float st = mod(time, 0.125);\r\n    bool isShort = true; // True for 16th note, false for 8th note\r\n    vec2 nn = vec2(0.,0.); // note number, trigger short note\r\n    nn = (sx == 0. || sx == 5. || sx==8.) ? vec2(33,1) : \r\n         (sx == 2.) ? vec2(48,1) :\r\n         (sx == 3.) ? vec2(45,1) :\r\n         (sx == 14.) ? vec2(35,1) :\r\n         (sx == 15. || sx == 35.) ? vec2(36,1) :\r\n         (sx == 16. || sx == 21. || sx == 24. || sx == 30. || sx == 31.) ? vec2(26,1) :\r\n         (sx == 18.) ? vec2(41,1) :\r\n         (sx == 19.) ? vec2(38,1) :\r\n         (sx == 32. || sx == 37. || sx == 38. || sx == 40.) ? vec2(24,1) :\r\n         (sx == 34.) ? vec2(40,1) :\r\n         (sx == 46.) ? vec2(28,1) :\r\n         (sx == 47.) ? vec2(29,1) :\r\n         (sx == 48. || sx == 53. || sx == 54. || sx == 56. || sx == 57.) ? vec2(31,1) :\r\n         (sx == 50.) ? vec2(47,1) :\r\n         (sx == 51. || sx == 58.) ? vec2(43,1) :\r\n         (sx == 60. || sx == 61.) ? vec2(32,1) :\r\n         (sx == 62.) ? vec2(44,1) :\r\n         vec2(0,0);\r\n    \r\n    \r\n    if(sx == 30. || sx == 56. || sx == 60.)\r\n    { // First half of 8th notes\r\n        isShort = false;\r\n    }\r\n    if(sx == 31. || sx == 57. || sx == 61.)\r\n    {  // Second half of 8th notes\r\n        st += 0.125;\r\n        isShort = false;\r\n    }\r\n    \r\n    \r\n    float fc = 400. + 50.*sin(TAU*time);\r\n    v += bass1(st, midicps(nn.x), fc) * nn.y;\r\n    \r\n    // Decay end of note to avoid clicks\r\n    if(isShort) v *= smoothstep(0.125,0.12,st);\r\n    else v *= smoothstep(0.125,0.12,st-0.125);\r\n    \r\n    return v;\r\n}\r\n\r\nvec2 padDrop1(float time, float fres)\r\n{\r\n    // Pad part for the drop : uses pad2 (the phase-modulation based pad)\r\n    vec2 v = vec2(0);\r\n    \r\n    float t = mod(time, 8.);\r\n    // Very sparse choice of notes.\r\n    // Chord transitions happen after the start of the bar.\r\n    vec4 chord = (t < 2.75) ? vec4(69,72,69,72) : \r\n    (t < 4.75) ? vec4(69,72,69,74) : (t < 6.75) ? vec4(69,72,67,72) : vec4(69,72,69,71);\r\n    // Funky automation to avoid boredom\r\n    float env = (0.05 + window(0.,4.,t) + window(4.,8.,t)) * exp(-5.*mod(-t, 0.25));\r\n    v += pad2(time, midicps(chord), fres) * env;\r\n    \r\n    return v;\r\n}\r\n\r\nvec2 fullDrop1(float time)\r\n{\r\n    // Full mix of the bass drop.\r\n    vec2 v = vec2(0);\r\n    float t = mod(time, 0.5);\r\n    // Fake sidechain compression again\r\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\r\n    // Hi-hat timbre rises from "dull" to "harsh"\r\n    float fhat = 5000. + 3000.*smoothstep(24.,32.,time);\r\n    \r\n    v += bassDrop1(time) * mix(pumping, 1., 0.8);\r\n    v += kick1(mod(time, 0.5) + 0.008);\r\n    \r\n    v += padDrop1(time, 8000.) * mix(pumping, 1., 0.05);\r\n    \r\n    if(time > 8.)\r\n    {\r\n        // Snare comes in after 4 bars.\r\n        v += snare2(mod(time-0.5, 1.));\r\n    }\r\n    if(time > 16.)\r\n    {\r\n        // Hi-hat comes in after 8 bars\r\n        // Short hi-hat sound with fast attack and decay. Slight swing.\r\n        v += hat2(mod(time, 0.25), fhat) * vec2(0.8,1.0) * 0.7;\r\n        v += hat2(mod(time-0.14, 0.25), fhat) * vec2(0.3,-0.2) * 0.7;\r\n    }\r\n    return v;\r\n}\r\n\r\nvec2 fermata1(float time)\r\n{\r\n    // 2-bar fermata after verse\r\n    vec2 v = vec2(0);\r\n    // Let the last marimba note decay\r\n    v += marimba1(time, midicps(69.));\r\n    // Let the pad go from bright to dark\r\n    float fc = 10000. * exp(-5.*smoothstep(0.,4.,time));\r\n    v += pad1(time, midicps(vec4(57,60,62,64)), fc, 2.) * smoothstep(0.,0.1,time) * smoothstep(4.,0.,time);\r\n    \r\n    // Riser before drop:\r\n    // Lots of low-frequency noise + a bit of high-frequency\r\n    vec2 noise = (coloredNoise2(time, 250., 250.) + 0.1*coloredNoise2(time, 8000., 2000.)) * 0.2 * exp(-6.*smoothstep(4.,1.,time)) * smoothstep(4.,3.99,time);\r\n    v += noise;\r\n    \r\n    return v;\r\n}\r\n\r\n\r\nvec2 teller1(float time)\r\n{\r\n    // 1-bar riser before chorus\r\n    vec2 v = vec2(0);\r\n    float t = mod(time, 0.5);\r\n    float fc = 10000.*exp(2.*(time-2.));\r\n    // Noise riser\r\n    vec2 riser = coloredNoise2(time, fc*0.3, fc*0.3);\r\n    v += riser * smoothstep(0.,2.,time) * 0.3 * exp((time-2.)*3.);\r\n    // Announce the "middle A" played by the lead synth on the chorus\r\n    vec2 teller = pad1(time, midicps(vec4(69)), fc, 2.);\r\n    v += teller;\r\n    return v;\r\n}\r\n\r\n\r\nvec2 verseTeller(float time)\r\n{\r\n    // Pre-announce the first note played by the marimba.\r\n    float fC5 = midicps(72.);\r\n    return (sin(TAU*(fC5+vec2(-2,2))*time) + 0.5*sin(TAU*(fC5+vec2(3,-3))*time)) * 0.1 * exp(-5.*(2.-time));\r\n    \r\n}\r\n\r\nvec2 fullSong(float time)\r\n{\r\n    // Combine all parts of the song into a structured whole.\r\n    \r\n    vec2 v = vec2(0);\r\n    \r\n    if(0.<time && time < 2.)\r\n    {\r\n        v += verseTeller(time);\r\n    }\r\n    \r\n    time -= 2.;\r\n    \r\n    if(0. < time && time < 32.)\r\n    {\r\n        v += fullVerse(time);\r\n    }\r\n        \r\n    time -= 32.;\r\n    \r\n    if(0. < time && time < 4.)\r\n    {\r\n        v += padVerse(time, 10000.) * smoothstep(0.5,0.,time);\r\n        v += fermata1(time);\r\n    }\r\n    \r\n    time -= 4.;\r\n    \r\n    if(0. < time && time < 32.)\r\n    {\r\n        v += fullDrop1(time);\r\n    }\r\n    \r\n    time -= 32.;\r\n    \r\n    if(0. < time && time < 4.)\r\n    {\r\n        v += bass1(time, midicps(33.), 400.);\r\n        v += pad2(time, midicps(vec4(69,71,69,72)), 8000.) * (0.5 + 0.3*cos(2.*TAU*time)) \r\n             * smoothstep(0.,0.5,time) * smoothstep(4.,0.,time);\r\n        v += verseTeller(time-2.);\r\n    }\r\n    \r\n    time -= 4.;\r\n    \r\n    if(0. < time && time < 16.)\r\n    {\r\n        v += fullVerse(time+16.);\r\n    }\r\n    \r\n    time -= 16.;\r\n    \r\n    if(0. < time && time < 4.)\r\n    {\r\n        v += fermata1(time);\r\n        v += teller1(time-2.) * smoothstep(2.,4.,time);\r\n    }\r\n    \r\n    time -= 4.;\r\n    \r\n    if(0. < time)\r\n    {\r\n        v += fullChorus(time) * smoothstep(48.,32.,time); // fade out on chorus\r\n    }\r\n    \r\n    return v;\r\n}\r\n\r\nvec2 mainSound( int samp, float time )\r\n{\r\n    vec2 v = vec2(0);\r\n    // v += fullSong(time);\r\n    // v += bassDrop1(time);\r\n\r\n    v += hat1(mod(time, 0.25)) * vec2(0.8,1.0);\r\n    v += hat1(mod(time-0.14, 0.25)) * vec2(0.3,-0.2);\r\n    v += snare1(mod(time, 1.));\r\n    v += kick1(mod(time + 0.5, 1.));\r\n\r\n    //v = fullChorus(time);\r\n    //v += vec2(kick1(mod(time, 0.5)));\r\n    \r\n    //v = fullDrop1(time);\r\n    \r\n    // v += pad1(mod(time, 4.0), vec4(440.0, 200.0, 300.0, 660.) * (mod(time, 4.0) < 2. ? 1.0 : 2.0), 8000., 2.0);\r\n    \r\n    // Avoid clicks at the beginning\r\n    return v * smoothstep(0.,0.01,time);\r\n}\r\n'}},i={};function s(r){if(i[r])return i[r].exports;var e=i[r]={exports:{}};return a[r](e,e.exports,s),e.exports}s.d=(r,e)=>{for(var n in e)s.o(e,n)&&!s.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:e[n]})},s.o=(r,e)=>Object.prototype.hasOwnProperty.call(r,e),r=function(){},e=function(r,e,n){return r*(1-n)+e*n},n=function(r,e){return Math.sin(r+e)+.5*Math.sin(2*r+e)+.25*Math.sin(4*r+e)},t=function(){function r(r,e,n){this.x=r,this.y=e,this.z=n}return r.prototype.add=function(e){return new r(this.x+e.x,this.y+e.y,this.z+e.z)},r.prototype.mul=function(e){return new r(this.x*e.x,this.y*e.y,this.z*e.z)},r.prototype.scale=function(e){return new r(this.x*e,this.y*e,this.z*e)},r.mix=function(n,t,o){return new r(e(n.x,t.x,o),e(n.y,t.y,o),e(n.z,t.z,o))},r.fbm=function(e){return new r(n(11431,e),n(23123,e),n(87034,e))},r}(),o=new function(e,n,t,o,a,i,s,c,f,l,m,v){var u=this;this.init=function(){u.timeLength=e,u.isPlaying=!0,u.needsUpdate=!1,u.time=0,u.debugFrameNumber=-1,u.uniformArray=[],u.uniforms={};var d=u.audioContext=new window.AudioContext,p=u.canvas=document.createElement("canvas");p.width=window.innerWidth,p.height=window.innerHeight,window.document.body.appendChild(p);var h=p.getContext("webgl2",{preserveDrawingBuffer:!0});if(h)if(h.getExtension("EXT_color_buffer_float"))if(h.getExtension("OES_texture_float_linear")){h.enable(h.CULL_FACE);var g=[[1,1],[-1,1],[1,-1],[-1,-1]],x=new Float32Array([].concat.apply([],g)),b=h.createBuffer();h.bindBuffer(h.ARRAY_BUFFER,b),h.bufferData(h.ARRAY_BUFFER,x,h.STATIC_DRAW),h.bindBuffer(h.ARRAY_BUFFER,null);var y=[[0,1,2],[3,2,1]],T=new Uint16Array([].concat.apply([],y)),w=h.createBuffer();h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,w),h.bufferData(h.ELEMENT_ARRAY_BUFFER,T,h.STATIC_DRAW),h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,null);var E=h.createVertexArray(),_=[],S=v(h),A=(t.split("\n").length,function(r,e){var n=h.createShader(e);if(h.shaderSource(n,r),h.compileShader(n),!h.getShaderParameter(n,h.COMPILE_STATUS)){var t=h.getShaderInfoLog(n);console.log(r,t)}return n}),R=function(r){var e=[A(n,h.VERTEX_SHADER),A(r,h.FRAGMENT_SHADER)],t=h.createProgram();return e.forEach((function(r){return h.attachShader(t,r)})),h.linkProgram(t),h.getProgramParameter(t,h.LINK_STATUS)||console.log(h.getProgramInfoLog(t)),t},C=function(r){if(1===r.type)return{frameBuffer:null,texture:null};var e=r.uniforms.iResolution.value[0],n=r.uniforms.iResolution.value[1],t=h.FLOAT,o=h.RGBA32F,a=h.LINEAR;4===r.type&&(e=512,n=512,t=h.UNSIGNED_BYTE,o=h.RGBA,a=h.NEAREST);var i=h.createFramebuffer();h.bindFramebuffer(h.FRAMEBUFFER,i);var s=h.createTexture();return h.bindTexture(h.TEXTURE_2D,s),h.texImage2D(h.TEXTURE_2D,0,o,e,n,0,h.RGBA,t,null),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MAG_FILTER,a),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MIN_FILTER,a),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_S,h.CLAMP_TO_EDGE),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_T,h.CLAMP_TO_EDGE),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,s,0),h.bindTexture(h.TEXTURE_2D,null),h.bindRenderbuffer(h.RENDERBUFFER,null),h.bindFramebuffer(h.FRAMEBUFFER,null),{frameBuffer:i,texture:s}},F=function(e,n,t,o){!function(r){h.bindVertexArray(E),h.bindBuffer(h.ARRAY_BUFFER,b),h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,w);var e=h.getAttribLocation(r,"vert2d"),n=h.FLOAT,t=g[0].length,o=t*Float32Array.BYTES_PER_ELEMENT;h.enableVertexAttribArray(e),h.vertexAttribPointer(e,t,n,!1,o,0),h.bindVertexArray(null)}(e);var s=new r;if(s.program=e,s.index=n,s.type=t,s.scale=o,s.uniforms={iResolution:{type:"v3",value:[p.width*s.scale,p.height*s.scale,0]},iTime:{type:"f",value:0},iPrevPass:{type:"t",value:Math.max(s.index-1,0)},iChannel0:{type:"t",value:s.index},iBeforeBloom:{type:"t",value:Math.max(a-1,0)},iBlockOffset:{type:"f",value:0},iSampleRate:{type:"f",value:d.sampleRate},iTextTexture:{type:"t",value:0}},3===t){var c=n-(a+i);s.uniforms.iPairBloomDown={type:"t",value:n-2*c}}return u.uniformArray.forEach((function(r){s.uniforms[r.key]={type:"number"==typeof r.initValue?"f":"v3",value:r.initValue}})),s.locations=function(r){var e={};return Object.keys(r.uniforms).forEach((function(n){e[n]=h.getUniformLocation(r.program,n)})),e}(s),s.front=C(s),s.back=C(s),s},U=function(r){h.useProgram(r.program),h.bindFramebuffer(h.FRAMEBUFFER,r.front.frameBuffer);for(var e=0,n=Object.entries(r.uniforms);e<n.length;e++){var t=n[e],o=t[0],a=t[1],i={f:h.uniform1f,v3:h.uniform3fv},s={iPrevPass:0,iBeforeBloom:1,iPairBloomDown:2,iTextTexture:3,iChannel0:4};"t"===a.type?(h.activeTexture(h.TEXTURE0+s[o]),"iTextTexture"===o?h.bindTexture(h.TEXTURE_2D,S):h.bindTexture(h.TEXTURE_2D,_[a.value].back.texture),h.uniform1i(r.locations[o],s[o])):i[a.type].call(h,r.locations[o],a.value)}h.bindVertexArray(E);var c=0*y[0].length;h.drawElements(h.TRIANGLES,T.length,h.UNSIGNED_SHORT,c);var f=h.getError();f!==h.NO_ERROR&&console.log(f),h.bindVertexArray(null),h.useProgram(null);var l=r.front;r.front=r.back,r.back=l};u.setSize=function(r,e){var n=h.canvas;n.width=r,n.height=e,h.viewport(0,0,r,e),_.forEach((function(n){h.deleteFramebuffer(n.front.frameBuffer),h.deleteFramebuffer(n.back.frameBuffer),h.deleteTexture(n.front.texture),h.deleteTexture(n.back.texture),n.uniforms.iResolution.value=[r*n.scale,e*n.scale,0],n.front=C(n),n.back=C(n)}))},u.playSound=function(){u.audioSource.start(u.audioContext.currentTime,u.time%u.timeLength)},u.render=function(){_.forEach((function(r){r.uniforms.iTime.value=u.time;for(var e=0,n=Object.entries(u.uniforms);e<n.length;e++){var t=n[e],o=t[0],a=t[1];void 0!==r.uniforms[o]&&(r.uniforms[o].value="number"==typeof a?a:[a[0]/255,a[1]/255,a[2]/255])}U(r)}))};var L=function(r){for(var e,n=/uniform (float|vec3) (g.+);\s*(\/\/ ([\-\d\.-]+))?( ([\-\d\.]+) ([\-\d\.]+))?( [\w\d]+)?/g;null!==(e=n.exec(r));){var t;t="float"===e[1]?{key:e[2],initValue:void 0!==e[4]?parseFloat(e[4]):0}:{key:e[2],initValue:[parseFloat(e[4]),parseFloat(e[6]),parseFloat(e[7])]},u.uniforms[t.key]||(u.uniformArray.push(t),u.uniforms[t.key]=t.initValue)}};L(t),o.forEach((function(r){L(r)})),L(s),L(c),L(f),L(l);var P=0;o.forEach((function(r,e,n){if(e===a){_.push(F(R(t+s),P,2,1)),P++;for(var o=1,m=0;m<i;m++)o*=.5,_.push(F(R(t+c),P,2,o)),P++;for(m=0;m<i-1;m++)o*=2,_.push(F(R(t+f),P,3,o)),P++;_.push(F(R(t+l),P,3,1)),P++}_.push(F(R(t+r),P,e<n.length-1?0:1,1)),P++})),function(){for(var r=Math.ceil(d.sampleRate*e),n=d.createBuffer(2,r,d.sampleRate),t=262144,o=r/t,a=R(m),i=F(a,0,4,1),s=0;s<o;s++){i.uniforms.iBlockOffset.value=s*t/d.sampleRate,U(i);var c=new Uint8Array(1048576);h.readPixels(0,0,512,512,h.RGBA,h.UNSIGNED_BYTE,c);for(var f=n.getChannelData(0),l=n.getChannelData(1),v=0;v<t;v++)f[s*t+v]=(c[4*v+0]+256*c[4*v+1])/65535*2-1,l[s*t+v]=(c[4*v+2]+256*c[4*v+3])/65535*2-1}var p,g,x,b;u.audioSource=d.createBufferSource(),p=u,g=void 0,b=function(){var r,e;return function(r,e){var n,t,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,t&&(o=2&a[0]?t.return:a[0]?t.throw||((o=t.return)&&o.call(t),0):t.next)&&!(o=o.call(t,a[1])).done)return o;switch(t=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,t=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!((o=(o=i.trys).length>0&&o[o.length-1])||6!==a[0]&&2!==a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=e.call(r,i)}catch(r){a=[6,r],t=0}finally{n=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}(this,(function(n){switch(n.label){case 0:return[4,fetch("230502_demo.wav")];case 1:return[4,n.sent().arrayBuffer()];case 2:return r=n.sent(),e=this.audioSource,[4,d.decodeAudioData(r)];case 3:return e.buffer=n.sent(),[2]}}))},new((x=void 0)||(x=Promise))((function(r,e){function n(r){try{o(b.next(r))}catch(r){e(r)}}function t(r){try{o(b.throw(r))}catch(r){e(r)}}function o(e){var o;e.done?r(e.value):(o=e.value,o instanceof x?o:new x((function(r){r(o)}))).then(n,t)}o((b=b.apply(p,g||[])).next())})),u.audioSource.loop=!0,u.audioSource.connect(d.destination)}();var I=0,B=null,k=function(r){requestAnimationFrame(k),B||(B=r);var e=.001*(r-I);u.isPlaying||u.needsUpdate,null!=u.onRender&&u.onRender(u.time,e),u.render(),u.time=.001*(r-B),u.needsUpdate=!1,I=r};u.play=function(){requestAnimationFrame(k)}}else alert("need OES_texture_float_linear");else alert("need EXT_color_buffer_float");else console.log("WebGL 2 is not supported...")}}(160,s(21).Z,s(696).Z,[s(681).Z,s(905).Z],-1,5,s(222).Z,s(370).Z,s(775).Z,s(526).Z,s(405).Z,(function(r){var e=document.createElement("canvas"),n=e.getContext("2d"),t=["A 64K INTRO","GRAPHICS","gam0022","MUSIC","sadakkey","RE: SIMULATED","REALITY","MERCURY","RGBA & TBC","Ctrl-Alt-Test","Conspiracy","Poo-Brain","Fairlight","kaneta","FMS_Cat",String.fromCharCode(189)+"-bit Cheese","Prismbeings","0x4015 & YET1","LJ & Alcatraz","logicoma","Polarity"];e.width=2048,e.height=4096,n.clearRect(0,0,e.width,e.height),n.fillStyle="black",n.fillRect(0,0,e.width,e.height),n.font="110px arial",n.textAlign="center",n.textBaseline="middle",n.fillStyle="white",t.forEach((function(r,t){n.fillText(r,e.width/2,64+128*t)}));var o=r.createTexture();return r.bindTexture(r.TEXTURE_2D,o),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),o})),function(){function r(r){this.input=r,this.begin=0,this.done=!1}r.prototype.then=function(r,e){return this.done||this.input<this.begin?this:this.input>=this.begin+r?(this.begin+=r,this):(e(this.input-this.begin),this.done=!0,this)},r.prototype.over=function(r){return this.done||(r(this.input-this.begin),this.done=!0),this}}(),window.addEventListener("load",(function(){var r=!1,e=document.createElement("style");e.innerText=s(434).Z,document.head.appendChild(e),document.addEventListener("fullscreenchange",(function(){document.body.style.cursor=window.document.fullscreenElement?"none":"auto"}));var n=document.createElement("div");n.className="container",document.body.appendChild(n);var a=document.createElement("p");a.innerHTML="RESOLUTION: ",n.appendChild(a);var i=document.createElement("select");i.innerHTML='\n    <option value="0.25">LOW 25%</option>\n    <option value="0.5">REGULAR 50%</option>\n    <option value="0.75">REGULAR 75%</option>\n    <option value="1.0" selected>FULL 100%</option>\n    ',a.appendChild(i);var c=document.createElement("p");n.appendChild(c),c.innerHTML="CLICK TO START",c.className="button",c.onclick=function(){c.remove(),a.remove();var e=document.createElement("p");e.innerHTML='LOADING <div class="lds-facebook"><div></div><div></div><div></div></div>',n.appendChild(e);var s=document.createElement("p");s.innerHTML="It takes about one minute. Please wait.",s.style.fontSize="50px",n.appendChild(s),document.body.requestFullscreen().then((function(){setTimeout((function(){o.onRender=function(e){var n,a;n=new t(0,0,10),a=new t(0,0,0),o.uniformArray.forEach((function(r){o.uniforms[r.key]=r.initValue})),o.uniforms.gCameraEyeX=n.x,o.uniforms.gCameraEyeY=n.y,o.uniforms.gCameraEyeZ=n.z,o.uniforms.gCameraTargetX=a.x,o.uniforms.gCameraTargetY=a.y,o.uniforms.gCameraTargetZ=a.z,!r&&e>o.timeLength+2&&(document.exitFullscreen(),r=!0)},o.init(),n.remove();var e=function(){var r=parseFloat(i.value);o.setSize(window.innerWidth*r,window.innerHeight*r)};window.addEventListener("resize",e),e(),setTimeout((function(){o.play(),o.playSound()}),2500)}),1e3)}))}}),!1)})();