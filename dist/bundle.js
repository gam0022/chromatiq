(()=>{"use strict";var e,n,t,o,a,r,i,s={434:(e,n,t)=>{t.d(n,{Z:()=>o});const o="body{background-color:#000;margin:0;padding:0}#c{display:none}canvas{display:block;position:absolute;top:0;left:0;right:0;bottom:0;margin:auto}.container{display:flex;flex-direction:column;position:absolute;top:0;justify-content:center;align-items:center;width:100%;height:100%;color:#fff}p{font-size:100px;font-family:arial;text-align:center}.button{border-style:solid;padding:10px 20px;animation:blinkAnime .85714285714s infinite alternate}@keyframes blinkAnime{0%{border-color:#000}100%{border-color:#fff}}select{font-size:100px;font-family:arial;text-align:center}.lds-facebook{display:inline-block;position:relative;width:80px;height:80px}.lds-facebook div{display:inline-block;position:absolute;left:8px;width:16px;background:#fff;animation:lds-facebook 1.2s cubic-bezier(0,.5,.5,1) infinite}.lds-facebook div:nth-child(1){left:8px;animation-delay:-.24s}.lds-facebook div:nth-child(2){left:32px;animation-delay:-.12s}.lds-facebook div:nth-child(3){left:56px;animation-delay:0}@keyframes lds-facebook{0%{top:8px;height:64px}100%,50%{top:24px;height:32px}}"},370:(e,n,t)=>{t.d(n,{Z:()=>o});const o="void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    fragColor = vec4(tap4(iPrevPass, uv, texelSize), 1.0);\n}"},526:(e,n,t)=>{t.d(n,{Z:()=>o});const o="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomIntensity;  // 1 0 30\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iBeforeBloom, uv).rgb;\n    vec3 pair = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomIntensity * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},222:(e,n,t)=>{t.d(n,{Z:()=>o});const o="float brightness(vec3 c) { return max(max(c.r, c.g), c.b); }\n\nuniform float gBloomThreshold;  // 1.0 0 100 bloom\nuniform float gBloomSoftKnee;   // 0.5 0 4\n\n// https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Runtime/Components/BloomComponent.cs#L65-L67\n// https://github.com/Unity-Technologies/PostProcessing/blob/v1/PostProcessing/Resources/Shaders/Bloom.shader#L86-L117\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float softKnee = gBloomSoftKnee;\n    float lthresh = gBloomThreshold;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iPrevPass, uv);\n    vec3 m = color.rgb;\n    float br = brightness(m);\n\n    float knee = lthresh * softKnee + 1e-5;\n    vec3 curve = vec3(lthresh - knee, knee * 2.0, 0.25 / knee);\n    float rq = clamp(br - curve.x, 0.0, curve.y);\n    rq = curve.z * rq * rq;\n\n    m *= max(rq, br - lthresh) / max(br, 1e-5);\n    m = max(m, vec3(0.0));\n\n    fragColor = vec4(m, color.a);\n}"},775:(e,n,t)=>{t.d(n,{Z:()=>o});const o="uniform sampler2D iBeforeBloom;\nuniform sampler2D iPairBloomDown;\n\nuniform float gBloomSpread;  // 1.3 1 2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec3 col = texture(iPairBloomDown, uv).rgb;\n    fragColor = vec4(col + gBloomSpread * tap4(iPrevPass, uv, texelSize), 1.0);\n}"},21:(e,n,t)=>{t.d(n,{Z:()=>o});const o="#version 300 es\n\ninvariant gl_Position;\nin vec2 vert2d;\n\nvoid main(void) { gl_Position = vec4(vert2d, 0, 1); }\n"},696:(e,n,t)=>{t.d(n,{Z:()=>o});const o="#version 300 es\r\nprecision highp float;\r\nprecision highp int;\r\nprecision mediump sampler3D;\r\n\r\n// #define AA\r\n\r\nuniform vec3 iResolution;\r\nuniform float iTime;\r\nuniform sampler2D iChannel0; // first pass\r\nuniform sampler2D iPrevPass;\r\nuniform sampler2D iTextTexture;\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord);\r\n\r\nout vec4 outColor;\r\nvoid main(void) {\r\n    vec4 c;\r\n#ifdef AA\r\n    vec4 t;\r\n    c = vec4(0.0);\r\n    for (int y = 0; y < 2; y++) {\r\n        for (int x = 0; x < 2; x++) {\r\n            vec2 sub = vec2(float(x), float(y)) * 0.5;  // FIXME\r\n            vec2 uv = gl_FragCoord.xy + sub;\r\n            mainImage(t, uv);\r\n            c += 0.25 * t;\r\n        }\r\n    }\r\n#else\r\n    mainImage(c, gl_FragCoord.xy);\r\n#endif\r\n    outColor = c;\r\n}\r\n\r\n// consts\r\nconst float PI = 3.14159265359;\r\nconst float TAU = 6.28318530718;\r\nconst float PIH = 1.57079632679;\r\n\r\n#define BPM 120.0\r\n#define beat (iTime * BPM / 60.0)\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\n// Hash without Sine by David Hoskins.\r\n// https://www.shadertoy.com/view/4djSRW\r\nfloat hash11(float p) {\r\n    p = fract(p * .1031);\r\n    p *= p + 33.33;\r\n    p *= p + p;\r\n    return fract(p);\r\n}\r\n\r\nfloat hash12(vec2 p) {\r\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec2 hash23(vec3 p3) {\r\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n}\r\n\r\n// hemisphere hash function based on a hash by Slerpy\r\nvec3 hashHs(vec3 n, vec3 seed) {\r\n    vec2 h = hash23(seed);\r\n    float a = h.x * 2. - 1.;\r\n    float b = TAU * h.y * 2. - 1.;\r\n    float c = sqrt(1. - a * a);\r\n    vec3 r = vec3(c * cos(b), a, c * sin(b));\r\n    return r;\r\n}\r\n\r\nvec3 tap4(sampler2D tex, vec2 uv, vec2 texelSize) {\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    vec3 s;\r\n    s = texture(tex, uv + d.xy).rgb;\r\n    s += texture(tex, uv + d.zy).rgb;\r\n    s += texture(tex, uv + d.xw).rgb;\r\n    s += texture(tex, uv + d.zw).rgb;\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\nvec2 textUv(vec2 uv, float id, vec2 p, float scale) {\r\n    uv -= p;\r\n    uv /= scale;\r\n\r\n    float offset = 128.0 / 4096.0;\r\n    float aspect = 2048.0 / 4096.0;\r\n    uv.x = 0.5 + 0.5 * uv.x;\r\n    uv.y = 0.5 - 0.5 * (aspect * uv.y + 1.0 - offset);\r\n    uv.y = clamp(uv.y + offset * id, offset * id, offset * (id + 1.0));\r\n\r\n    return uv;\r\n}\r\n\r\n"},905:(e,n,t)=>{t.d(n,{Z:()=>o});const o="uniform float gChromaticAberrationIntensity;  // 0.0003 0 0.1 post\nuniform float gChromaticAberrationDistance;   // 0.45 0 1\n\nuniform float gVignetteIntensity;   // 1.34 0 3\nuniform float gVignetteSmoothness;  // 2 0 5\nuniform float gVignetteRoundness;   // 1 0 1\n\nuniform float gTonemapExposure;  // 1 0.0 2\nuniform float gFlash;            // 0 0 1\nuniform float gFlashSpeed;       // 0 0 60\nuniform float gBlend;            // 0 -1 1\n\nuniform float gGlitchIntensity;  // 0 0 0.1\nuniform float gXSfhitGlitch;     // 0 0 0.1\nuniform float gInvertRate;       // 0 0 1\n\n// https://www.shadertoy.com/view/lsf3WH\n// Noise - value - 2D by iq\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), hash12(i + vec2(1.0, 0.0)), u.x), mix(hash12(i + vec2(0.0, 1.0)), hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(in vec2 uv) {\n    float f = 0.0;\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    f = 0.5000 * noise(uv);\n    uv = m * uv;\n    f += 0.2500 * noise(uv);\n    uv = m * uv;\n    f += 0.1250 * noise(uv);\n    uv = m * uv;\n    f += 0.0625 * noise(uv);\n    uv = m * uv;\n    return f;\n}\n\nvec3 chromaticAberration(vec2 uv) {\n    uv.x += gXSfhitGlitch * (fbm(vec2(232.0 * uv.y, beat)) - 0.5);\n\n    vec2 d = abs(uv - 0.5);\n    float f = mix(0.5, dot(d, d), gChromaticAberrationDistance);\n    f *= f * gChromaticAberrationIntensity;\n    vec2 shift = vec2(f);\n\n    float a = 2.0 * hash11(beat) - 1.0;\n    vec2 grid = hash23(vec3(floor(vec2(uv.x * (4.0 + 8.0 * a), (uv.y + a) * 32.0)), beat));\n    grid = 2.0 * grid - 1.0;\n    shift += gGlitchIntensity * grid;\n\n    vec3 col;\n    col.r = texture(iPrevPass, uv + shift).r;\n    col.g = texture(iPrevPass, uv).g;\n    col.b = texture(iPrevPass, uv - shift).b;\n    return col;\n}\n\nfloat vignette(vec2 uv) {\n    vec2 d = abs(uv - 0.5) * gVignetteIntensity;\n    float roundness = (1.0 - gVignetteRoundness) * 6.0 + gVignetteRoundness;\n    d = pow(d, vec2(roundness));\n    return pow(saturate(1.0 - dot(d, d)), gVignetteSmoothness);\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 invert(vec3 c, vec2 uv) {\n    if (hash12(vec2(floor(uv.y * gInvertRate * 32.0), beat)) < gInvertRate) {\n        return vec3(1.0) - c;\n    } else {\n        return c;\n    }\n}\n\nvec3 flash(vec3 c) {\n    c = mix(c, vec3(1.0), gFlash * saturate(cos(iTime * PI * gFlashSpeed)));\n    return c;\n}\n\nvec3 blend(vec3 c) {\n    c = mix(c, vec3(1.0), saturate(gBlend));\n    c = mix(c, vec3(0.0), saturate(-gBlend));\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = chromaticAberration(uv);\n    col *= vignette(uv);\n    col = acesFilm(col * gTonemapExposure);\n    col = pow(col, vec3(1.0 / 2.2));\n    col = invert(col, uv);\n    col = flash(col);\n    col = blend(col);\n    fragColor = vec4(col, 1.0);\n}"},681:(e,n,t)=>{t.d(n,{Z:()=>o});const o="uniform float gCameraEyeX;     // -0.08828528243935951 -100 100 camera\nuniform float gCameraEyeY;     // 3.5309297601209235 -100 100\nuniform float gCameraEyeZ;     // -2.705631420983895 -100 100\nuniform float gCameraTargetX;  // 0.7576763789243015 -100 100\nuniform float gCameraTargetY;  // 3.4515422110479044 -100 100\nuniform float gCameraTargetZ;  // -0.21633410393024527 -100 100\nuniform float gCameraFov;      // 37.88049605411499 0 180\n\nuniform float gUseBackbuffer;      // 0.5 0 1\n\n#define opRep(p, a) p = mod(p, a) - a * 0.5\n#define opRepLim(p, c, l) p = p - c * clamp(floor(p / c + 0.5), -l, l);\n\nvec3 ro, target;\nfloat fov;\nvec3 scol;\n// float beat;\nfloat beatTau;\nfloat beatPhase;\n\n// Timeline\nfloat prevEndTime = 0., t = 0.;\n#define TL(beat, end) if (t = beat - prevEndTime, beat < (prevEndTime = end))\n\n// Material Types\n#define VOL 0.0\n#define SOL 1.0\n\n// https://www.shadertoy.com/view/3tX3R4\nfloat remap(float val, float im, float ix, float om, float ox) { return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox); }\nfloat remap01(float val, float im, float ix) { return saturate((val - im) / (ix - im)); }\n\nvoid opUnion(inout vec4 m, float d, float type, float roughness_or_emissive, float hue) {\n    if (d < m.x) m = vec4(d, type, roughness_or_emissive, hue);\n}\n\nvec3 pal(vec4 m) {\n    // Integer part: Blend ratio with white (0-10)\n    // Decimal part: Hue (0-1)\n    vec3 col = vec3(0.5) + 0.5 * cos(TAU * (vec3(0.0, 0.33, 0.67) + m.w));\n    return mix(col, vec3(1), 0.1 * floor(m.w));\n}\n\n// Ref. Energy Lab by kaneta\n// https://www.shadertoy.com/view/3dd3WB\nfloat smoothPulse(float start, float end, float period, float smoothness, float t) {\n    float h = abs(end - start) * 0.5;\n    t = mod(t, period);\n    return smoothstep(start, start + h * smoothness, t) - smoothstep(end - h * smoothness, end, t);\n}\n\n// https://www.shadertoy.com/view/lssGWn\nfloat sdEgg(vec3 p, float r) {\n    p.y *= 0.8;\n    p.y += 0.15 * pow(1.5 * dot(p.xz, p.xz), 0.6);\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n\nvec4 map(vec3 pos) {\n    vec4 m = vec4(2, VOL, 0, 0);\n    // x: Distance\n    // y: MaterialType (VOL or SOL)\n    // z: Roughness in (0-1), Emissive when z>1\n    // w: ColorPalette\n\n    float roughness = 0.05;\n    float a = .1;\n    float W = 16.;\n    float H = 8.;\n    float D = 32.;\n\n    vec3 p1 = pos;\n    // p1.y += H;\n    // opRep(p1.z, 2. * D);\n    p1 -= vec3(8.5, 0.0, 4.5) * 0.2;\n    \n    vec4 ifs_p1 = vec4(1.57 / 4. + sin(beatPhase / 4.), 3.59 / 4., 0, 0);\n    \n    for(int i = 0; i < 4; i++){\n        p1 = abs(p1 + vec3(8.5, 0.0, 4.5) * 0.2) - vec3(8.5, 0.0, 4.5) * 0.2;\n        rot(p1.xz, TAU * ifs_p1.x);\n        rot(p1.zy, TAU * ifs_p1.y);\n    }\n\n    //p1 *= 1.5;\n    //p1.y -= 2.;\n\n    \n    opUnion(m, sdBox(p1, vec3(2, 5, 2)), SOL, roughness, 0.5);\n    opUnion(m, sdBox(p1, vec3(0.1, 5, 2.1)), SOL, roughness + 1., 0.5 + step(16., beat) * fract(beat+length(p1)));\n    //opUnion(m, sdBox(p1, vec3(2.0, 0.3, 2.01)), SOL, 1.1, 0.5);\n\n\n    // background\n    vec3 p2 = pos;\n    // p2.y -= -H;\n    p2 = abs(p2);\n    // opUnion(m, sdBox(p2 + vec3(0, H, 0), vec3(W, a, D)), SOL, 0.6, 0.5);\n    float th = -step(mod(beat, 8.), 4.);\n    opUnion(m, sdBox(p2 - vec3(0, H, 0), vec3(W, a, D)), SOL, roughness + 0.*step(0., pos.y) * step(sin(p2.x), th), 10.0);\n    opUnion(m, sdBox(p2 - vec3(0, 0, D), vec3(W, H, a)), SOL, roughness + step(sin(p2.y), 0.), 10.0);\n    opUnion(m, sdBox(p2 - vec3(W, 0, 0), vec3(a, H, D)), SOL, roughness + step(sin(p2.z), th), 10.0);\n\n    return m;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0, .05);\n    return normalize(map(p).x - vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\n// Ref. EOT - Grid scene by Virgill\n// https://www.shadertoy.com/view/Xt3cWS\nvoid madtracer(vec3 ro1, vec3 rd1, float seed) {\n    scol = vec3(0);\n    float t = 0., t2 = 0.;\n    vec4 m1, m2;\n    vec3 rd2, ro2, nor2;\n    for (int i = 0; i < 160; i++) {\n        m1 = map(ro1 + rd1 * t);\n        // t += m1.y == VOL ? 0.25 * abs(m1.x) + 0.0008 : 0.25 * m1.x;\n        t += 0.25 * mix(abs(m1.x) + 0.0032, m1.x, m1.y);\n        ro2 = ro1 + rd1 * t;\n        nor2 = normal(ro2);\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, vec3(seed, i, iTime)), saturate(m1.z));\n        m2 = map(ro2 + rd2 * t2);\n        // t2 += m2.y == VOL ? 0.25 * abs(m2.x) : 0.25 * m2.x;\n        t2 += 0.25 * mix(abs(m2.x), m2.x, m2.y);\n        scol += .007 * (pal(m2) * step(1., m2.z) + pal(m1) * step(1., m1.z));\n\n        // force disable unroll for WebGL 1.0\n        if (t < -1.) break;\n    }\n}\n\nvoid raymarching(vec3 ro1, vec3 rd1) {\n    scol = vec3(0);\n    float t = 0.;\n    vec4 m;\n    for (int i = 0; i < 160; i++) {\n        vec3 p = ro1 + rd1 * t;\n        m = map(p);\n        t += m.x;\n\n        if (m.x < 0.01) {\n            vec3 light = normalize(vec3(1, 1, -1));\n            vec3 albedo = vec3(0.3);\n            if (m.z > 1.) albedo = pal(m);\n            scol = albedo * (0.5 + 0.5 * saturate(dot(normal(p), light)));\n            break;\n        }\n    }\n}\n\nvoid setCamera(vec4 v, float roY) {\n    vec4 u = v / vec2(1200, 675).xyxy;\n    vec4 n = u * 2. - 1.;\n    ro = vec3(8. * n.z, roY, -64. * u.w);\n    target = ro + vec3(2. * n.xy, 1);\n}\n\nvoid setCameraRot(vec4 v, float roY) {\n    vec4 u = v / vec2(1200, 675).xyxy;\n    vec4 n = u * 2. - 1.;\n    ro = vec3(8. * n.z, roY, 16. * u.w);\n    vec3 fwd = vec3(0, 0, 1);\n    rot(fwd.xz, n.x * TAU / 2.);\n    rot(fwd.yz, n.y * TAU / 4.);\n    target = ro + fwd;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // beat = iTime * BPM / 60.0;\n    beatTau = beat * TAU;\n    beatPhase = floor(beat)+(.5+.5*cos(TAU * .5 * exp(-5.0*fract(beat))));\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Camera\n    vec2 noise = hash23(vec3(iTime, fragCoord)) - 0.5;  // AA\n    vec2 uv2 = (2. * (fragCoord.xy + noise) - iResolution.xy) / iResolution.x;\n\n    float FD = 675. * 3.;  // Final Room Depth\n    fov = 80.;\n\n#define DEBUG_CAMERA\n#ifdef DEBUG_CAMERA\n    setCamera(abs(vec4(538, 291, 831, 300)), 3.0);\n    // setCameraRot(abs(iMouse), 3.);\n#else\n\n    // Room1\n    TL(beat, 4. * 8.) setCamera(vec4(600, 250. + t * 3., 600, 243. - t * 6.), 3.);\n    else TL(beat, 4. * 10.) setCamera(vec4(600, 307, 600, 44. + t * 4.), 3.);\n    else TL(beat, 4. * 12.) setCamera(vec4(494, 322, 695, 216), 2.4 + 0.2 * t);\n    else TL(beat, 4. * 14.) setCamera(vec4(600, 481. + 10. * t, 600, 59), 3.);\n    else TL(beat, 4. * 16.) setCamera(vec4(909, 158. - 10.0 * t, 470. + 10.0 * t, 158), 3.);\n    else TL(beat, 4. * 18.) setCamera(vec4(541, 335., 609., 384. + 2.0 * t), 3.);\n\n    else TL(beat, 4. * 72.) {\n        setCamera(vec4(645, 326., 705., FD + 272.), 1.9);\n        fov = mix(90., 120., exp(-t));\n    }\n    \n    setCamera(vec4(538, 291, 831, 492), 5.);\n\n#endif\n\n    vec3 up = vec3(0, 1, 0);\n    vec3 fwd = normalize(target - ro);\n    vec3 right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    vec3 rd = normalize(right * uv2.x + up * uv2.y + fwd / tan(fov * TAU / 720.));\n\n//#define DEBUG_SCENE\n#ifdef DEBUG_SCENE\n    raymarching(ro, rd);\n    fragColor = vec4(scol, 1.);\n#else\n    madtracer(ro, rd, hash12(uv2));\n    vec3 bufa = texture(iChannel0, uv).xyz;\n\n    if (uv.x > 0.5) bufa *= 0.;\n    \n    // fade out\n    // scol = mix(scol, vec3(0), remap01(beat, 4. * 70., 4. * 72.));\n    \n    // fragColor = saturate(vec4(1. * scol + 0.0 * bufa, 0.));\n    fragColor = saturate(vec4(0.7 * scol + 0.7 * bufa, 0.));\n#endif\n}"},405:(e,n,t)=>{t.d(n,{Z:()=>o});const o='#version 300 es\nprecision mediump float;\nuniform float iSampleRate;\nuniform float iBlockOffset;\n\nvec2 mainSound(int samp, float time);\n\nout vec4 outColor;\nvoid main() {\n    float t = iBlockOffset + ((gl_FragCoord.x - 0.5) + (gl_FragCoord.y - 0.5) * 512.0) / iSampleRate;\n    vec2 y = mainSound(int(iSampleRate), t);\n    vec2 v = floor((0.5 + 0.5 * y) * 65536.0);\n    vec2 vl = mod(v, 256.0) / 255.0;\n    vec2 vh = floor(v / 256.0) / 255.0;\n    outColor = vec4(vl.x, vh.x, vl.y, vh.y);\n}\n\n//--------------------\n// ここから下を書き換える\n//--------------------\n\n// The code below is split into several parts.\n// UTILS - Constants and hash functions and stuff\n// WAVEFORMS - Basic noise and tone generators\n// INSTRUMENTS - Stuff that makes notes\n// PHRASES AND SONG PARTS - What to play, how to play it, up to the final mix.\n\n\n///////////////////////////////\n/////////// UTILS /////////////\n///////////////////////////////\n\n#define TAU (2.*3.1415926)\n// Convert MIDI note number to cycles per second\n#define midicps(n) (440.*exp(log(2.)*(n-69.)/12.))\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 rand2(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n////////////////////////////////////\n/////////// WAVEFORMS //////////////\n////////////////////////////////////\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    //sf = sf*sf*sf*(sf*(sf*6.0-15.0)+10.0); // quintic curve\n    // see https://iquilezles.org/articles/texture\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nvec2 noise2(float s){\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand2(float(si)), rand2(float(si+1)), sf) * 2. - 1.;\n}\n\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    //float n1 = noise(t*df);\n    //float n2 = noise(t*df - 100000.);\n    //vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    return sin(TAU*fc*fract(t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    vec2 noiz = noise2(t*df);\n    vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    return modul*noiz;\n}\n\n\nfloat window(float a, float b, float t)\n{\n    return smoothstep(a, (a+b)*0.5, t) * smoothstep(b, (a+b)*0.5, t);\n}\n\nfloat formantSin(float phase, float form)\n{\n    // Inspired by the wavetable "formant" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*phase);\n}\nvec2 formantSin2(vec2 phase, vec2 form)\n{\n    // Inspired by the wavetable "formant" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*phase);\n}\n\n\nfloat lpfSaw(float t, float f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\nvec2 lpfSaw(float t, vec2 f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    vec2 omega_c = 2.*3.14159*fc/f; // relative\n    vec2 t2 = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    vec2 alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    vec2 tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    vec2 phi = atan(tanphi);\n    vec2 A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    vec2 v = 1.-2.*t2 + A*exp(-alpha*t2) * cos(omega_c*t2+phi);\n    return v;\n}\n\n\n///////////////////////////////////\n//////// INSTRUMENTS //////////////\n///////////////////////////////////\n\nvec2 hat1(float t)\n{\n    // Smooth hi-hat, almost shaker-like\n    return coloredNoise2(t, 10000., 5000.) * smoothstep(0.,0.02,t) * smoothstep(0.06,0.01,t) * 0.1;\n}\n\nvec2 hat2(float t, float fc)\n{\n    // Short hi-hat with tuneable center frequency\n    return coloredNoise2(t, fc, fc-1000.) * smoothstep(0.,0.001,t) * smoothstep(0.03,0.01,t) * 0.1;\n}\n\nvec2 snare1(float t)\n{\n    // Composite snare\n    float body = (sin(TAU*t*250.) + sin(TAU*t*320.)) * smoothstep(0.1,0.0,t) * 1.;\n    vec2 timbre = coloredNoise2(t, 1000., 7000.) * exp(-12.*t) * smoothstep(0.5,0.,t) * 8.;\n    vec2 sig = (body+timbre) * smoothstep(0.,0.001,t);\n    sig = sig/(1.+abs(sig)); // distort\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    return sig * 0.1;\n}\n\nvec2 snare2(float t)\n{\n    // Basic noise-based snare\n    float noi = coloredNoise(t, 4000., 1000.) + coloredNoise(t, 4000., 3800.) + coloredNoise(t,8000.,7500.) * 0.5;\n    float env = smoothstep(0.,0.001,t) * smoothstep(0.2,0.05,t);\n    env *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    env *= (1. - 0.5*window(0.02,0.1,t)); // fake compression\n    vec2 sig = vec2(noi) * env;\n    sig = sig/(1.+abs(sig));\n    return sig * 0.1;\n}\n\nfloat kick1(float t)\n{\n    // Composite kick\n    \n    // Kick is composed of a decaying sine tone, and a burst of noise,\n    // all of it distorted and shaped with a nice envelope.\n    \n    // frequency is assumed to be f0 + df*exp(-t/dftime);\n    float f0 = 50., df=500., dftime=0.02;\n    float phase = TAU * (f0*t - df*dftime*exp(-t/dftime));\n    float body = sin(phase) * smoothstep(0.15,0.,t) * 2.;\n    float click = coloredNoise(t, 8000., 2000.) * smoothstep(0.01,0.0,t);\n    //float boom = sin(f0*TAU*t) * smoothstep(0.,0.02,t) * smoothstep(0.15,0.,t);\n    float sig = body + click;\n    sig = sig/(1.+abs(sig));\n    //sig += boom;\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    sig *= (1. + window(0.05,0.15,t)); // increase tail\n    return sig * 0.2;\n}\n\nvec2 bass1(float t, float f, float cutoff)\n{\n    // Composite bass\n    // (I\'m very happy about this one!)\n    \n    // "Cutoff" is not actually the cutoff frequency of a filter,\n    // but it controls the amount of high frequencies\n    // we bring in using the "formantSin" waveform.\n    cutoff *= exp(-t*5.);\n    float formant = max(cutoff/f, 1.);\n    // Pure sine tone\n    float funda = sin(TAU*f*t);\n    // Phase-modulated sine gives more "body" to the sound\n    float body = sin(2.*TAU*f*t + (0.2*formant)*sin(TAU*f*t));\n    // Gritty attack using a truncated sinusoid waveform\n    // (dephased for stereo effect)\n    vec2 highs = formantSin2(f*t + vec2(0,0.5), vec2(formant)) * exp(-t*10.);\n    vec2 sig = body + highs + funda;\n    // Two-rate envelope with a strong transient and long decay\n    sig *= (2.*exp(-t*20.) + exp(-t*2.));\n    sig *= (1. + 0.3*smoothstep(0.05,0.0,t)); // increase transient\n    \n    // Finally, add some distortion\n    //sig = sig / (1. + abs(sig)); // Feel free to try how this one sounds.\n    sig = sin(sig); // This one gives lovely sidebands when pushed hard.\n    return sig * 0.1;\n}\n\nvec2 pad1(float t, vec4 f, float fc, float Q)\n{\n    // Filtered sawtooth-based pad, playing four-note chords\n    \n    // f: frequencies of the four notes\n    // fc, Q: cutoff frequency and quality factor of the 12dB/octave lowpass filter\n    vec2 sig = vec2(0);\n    sig += lpfSaw(t, f.x+vec2(-2,2), fc, Q);\n    sig += lpfSaw(t, f.y+vec2(1.7,-1.7), fc, Q);\n    sig += lpfSaw(t, f.z+vec2(-0.5,0.5), fc, Q);\n    sig += lpfSaw(t, f.w+vec2(1.5,-1.5), fc, Q);\n    return sig * 0.02;\n}\n\nvec2 arp1(float t, vec4 f, float fc, float dur)\n{\n    // Plucky arpeggiator, playing 16th notes.\n    \n    // dur: decay time of the notes (amplitude and filter)\n    vec2 sig = vec2(0);\n    vec4 ts = mod(t-vec4(0,0.125,0.25,0.375), 0.5);\n    sig += lpfSaw(t, f.x, fc*exp(-ts.x/dur), 10.) * smoothstep(0.0,0.01,ts.x) * exp(-ts.x/dur);\n    sig += lpfSaw(t, f.y, fc*exp(-ts.y/dur), 10.) * smoothstep(0.0,0.01,ts.y) * exp(-ts.y/dur);\n    sig += lpfSaw(t, f.z, fc*exp(-ts.z/dur), 10.) * smoothstep(0.0,0.01,ts.z) * exp(-ts.z/dur);\n    sig += lpfSaw(t, f.w, fc*exp(-ts.w/dur), 10.) * smoothstep(0.0,0.01,ts.w) * exp(-ts.w/dur);\n    return sig * 0.04;\n}\n\nvec2 marimba1(float t, float f)\n{\n    // Simple phase-modulation based marimba\n    \n    vec2 sig = vec2(0);\n    // Super basic marimba sound\n    sig += sin(TAU*f*t + exp(-50.*t)*sin(TAU*7.*f*t)) * exp(-5.*t) * step(0.,t);\n    // Fake reverb effect: long-decay, stereo-detuned fundamental\n    sig += sin(TAU*(f+vec2(-2,2))*t) * exp(-1.5*t) * 0.5;\n    return vec2(sig) * 0.05;\n}\n\nvec2 pad2(float t, vec4 f, float fres)\n{\n    // Four-note, phase-modulation-based pad.\n    \n    // fres: center frequency of the faked "spectral aliasing"\n    \n    vec2 sig = vec2(0);\n    // Index of modulation\n    // https://en.wikipedia.org/wiki/Frequency_modulation#Modulation_index\n    vec4 iom1 = 2.+0.5*sin(t + vec4(0,1,2,3));\n    // Play an octave lower than asked\n    f *= 0.5;\n    // Modulator has frequency 2f -> odd harmonics only\n    sig += sin(TAU*t*f.x + iom1.x * sin(2.*TAU*t*(f.x+vec2(-1,1)))) * vec2(1,0);\n    sig += sin(TAU*t*f.y + iom1.y * sin(2.*TAU*t*(f.y+vec2(-1.2,0.8)))) * vec2(0.7,0.3);\n    sig += sin(TAU*t*f.z + iom1.z * sin(2.*TAU*t*(f.z+vec2(-0.5,1.5)))) * vec2(0.3,0.7);\n    sig += sin(TAU*t*f.w + iom1.w * sin(2.*TAU*t*(f.w+vec2(-1.3,0.7)))) * vec2(0,1);\n    \n    // Fake spectral aliasing, to add some high-end\n    vec2 warped = vec2(0);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.x)) * vec2(1,0);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.y)) * vec2(0.7,0.3);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.z)) * vec2(0.3,0.7);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.w)) * vec2(0,1);\n    \n    // Mix to taste\n    sig = (sig + 0.01*warped) * 0.02;\n    // Reduce stereo image\n    sig = mix(sig.xy, sig.yx, 0.1);\n    return sig;\n}\n\n\n////////////////////////////////////////////\n/////// PHRASES AND SONG PARTS /////////////\n////////////////////////////////////////////\n\n\nfloat leadphrasenote(float t)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // MIDI note number (or 0. if silence)\n    float note =\n        (t<0.5) ? 69. : (t<1.) ? 71. : (t<1.5) ? 72. : (t<1.75) ? 76. :\n        (t<3.0) ? 74. : (t<3.25) ? 0. : (t<3.5) ? 72. : (t<3.75) ? 74. :\n        (t<5.5) ? 76. : (t<5.75) ? 79. : (t<7.5) ? 71. : 0.;\n    return note;\n}\n\nvec2 leadphrase1(float t, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    \n    float note = leadphrasenote(t);\n    // Add some vibrato\n    float vibStrength = window(2.,3.,t) + window(4.,5.5,t) + window(6.,8.,t);\n    float f = midicps(note + vibStrength*0.01*sin(5.*TAU*t)/(t+0.1));\n    // Cut silence\n    float env = (note > 0.) ? 1. : 0.;\n    \n    // "Super-saw" lead\n    vec2 sig = lpfSaw(t, f+vec2(-2,2), fc, 1.);\n    sig += lpfSaw(t, f+vec2(3.2,-3.2), fc, 1.);\n    sig += lpfSaw(t, f, fc, 1.);\n    \n    // Distort\n    sig *= 2.;\n    sig = sig/(1.+abs(sig));\n    \n    return sig * 0.05 * env;\n}\n\nvec2 leadchorus(float t, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // Add delay effect\n    vec2 sig = leadphrase1(t, fc);\n    sig = mix(sig, sig.yx, 0.3);\n    sig += leadphrase1(mod(t-0.25,8.), fc*0.7).yx * vec2(0.5,-0.5);\n    sig += leadphrase1(mod(t-1., 8.), 1000.) * 0.5;\n    return sig;\n}\n\nvec2 basschorus(float t, float fc)\n{\n    // Bass of the final chorus:\n    // Simply play the fundamental of each bar, with octave jumps\n    \n    // Every second 8th note is an octave above\n    float octave = 12.*step(0.25,mod(t,0.5));\n    // Fundamental of each of the four bars\n    float note = (t<2.) ? 69.-36.+octave : \n                 (t<4.) ? 62.-36.+octave :\n                 (t<6.) ? 60.-36.+octave :\n                 67.-36.+octave;\n    \n    float t1 = mod(t, 0.25);\n    vec2 sig = bass1(t1, midicps(note), fc);\n    \n    return sig;\n}\n\nvec2 padchorus(float t, float fc, float Q)\n{\n    // Pad part for the final chorus\n    // Simply play the (slightly rich) chords\n    // ||: Am(add9) | Dm7 | C(add9) | G(add9) :||\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    \n    vec2 pad = pad1(t, midicps(chord), fc, Q);\n    return pad;\n}\n\n\nvec2 arpchorus(float t, float fc, float dur)\n{\n    // Arpeggiator part for the final chorus\n    // Simply arpeggiate the four chords\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    vec2 arp = arp1(t, midicps(chord+12.), fc, dur);\n    return arp;\n}\n\n\nvec2 fullChorus(float time)\n{\n    // Full mix for the final chorus\n    time = mod(time, 8.);\n    vec2 v = vec2(0);\n    \n    // Percussions (with a slight 16th-note swing)\n    v += hat1(mod(time, 0.25)) * vec2(0.8,1.0);\n    v += hat1(mod(time-0.14, 0.25)) * vec2(0.3,-0.2);\n    v += snare1(mod(time-0.5, 1.));\n    v += kick1(mod(time, 0.5));\n    \n    // Low-frequency oscillator on a macro control\n    float cutoff = 300. + 200.*sin(time);\n    \n    float t = mod(time, 0.5);\n    // Another LFO for fake sidechain compression ("pumping" effect)\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\n    \n    v += basschorus(mod(time,8.), cutoff) *mix(pumping, 1.,0.3);\n    \n    vec2 pads = padchorus(mod(time, 8.), 8000.-1000.*sin(time), 2.);\n    pads *= mix(pumping, 1., 0.1);\n    v += pads;\n    \n    // A third LFO to vary the note length of the arpeggiator\n    float dur = 0.2 * exp(0.2*sin(time*0.6));\n    vec2 arp = arpchorus(mod(time, 8.), 5000.-1000.*cos(0.7*time), dur);\n    v += arp * mix(pumping, 1.,0.2);\n    \n    v += leadchorus(mod(time,8.), 10000.) * mix(pumping,1.,0.5);\n    \n    return v;\n}\n\nvec2 padPhraseVerse(float time, float fc)\n{\n    // Pad during the verse: play three chords in four bars\n    // ||: Am(add11) | FMaj7 | Em7 | Em7 :||\n    float t = mod(time, 8.);\n    vec4 chord = (t<2.) ? vec4(57,60,62,64) : (t<4.) ? vec4(53,57,60,64) : vec4(52,55,62,64);\n    // Smoothe out the transitions from one chord to the next,\n    // as they are not masked by percussion.\n    float env = 1. - window(-0.1,0.1,t) - window(1.9,2.1,t) - window(3.9,4.1,t) - window(7.9,8.1,t);\n    // Add some movement with volume automation\n    env *= 1. + 0.2*window(0.25,0.5,mod(t,0.5));\n    return pad1(t, midicps(chord), fc*0.7, 2.) * env;\n}\n\nvec2 padVerse(float time, float fc)\n{\n    // Verse pad with delay effect\n    return padPhraseVerse(time, fc) + 0.5*padPhraseVerse(time-0.5,fc).yx + 0.2*padPhraseVerse(time-1.5,fc);\n}\n\nvec2 marimbaVerse(float t, float fc)\n{\n    // Marimba part for the verse:\n    // just a few notes, always the same.\n    vec2 v = vec2(0);\n    v += marimba1(mod(t-0.00,8.), midicps(72.));\n    v += marimba1(mod(t-0.75,8.), midicps(71.));\n    v += marimba1(mod(t-1.50,8.), midicps(69.));\n    v += marimba1(mod(t-2.25,8.), midicps(64.));\n    v += marimba1(mod(t-7.50,8.), midicps(69.));\n    v += marimba1(mod(t-7.75,8.), midicps(71.));\n    return v;\n}\n\nvec2 arpVerse(float time, float fc, float dur)\n{\n    // Verse arpeggiator: just arpeggiate the chords\n    // (different notes than the pad this time).\n    // Cutoff frequency and note duration will be varied for tension.\n    float t = mod(time, 8.);\n    vec4 chord = (t<2.) ? vec4(57,64,69,71) : (t<4.) ? vec4(57,64,65,72) : vec4(59,64,69,74);\n    return arp1(t, midicps(chord), fc, dur);\n}\n\nvec2 fullVerse(float time)\n{\n    vec2 v = vec2(0);\n    // Cutoff frequency: dark sound initially,\n    // but with a riser in the last four bars.\n    float fc = 400. - 100.*cos(time) + 10000. * pow(clamp((time-24.)/(32.-24.),0.,1.), 4.);\n    v += padVerse(time, fc) * 0.5;\n    v += marimbaVerse(time, fc);\n    if(time > 16.)\n    {\n        // Arpeggiator comes in after 8 bars, and note duration increases\n        // during the riser.\n        float dur = mix(0.05,0.5, smoothstep(24.,32.,time));\n        v += arpVerse(time, fc, dur) * smoothstep(16.,18.,time);\n    }\n    return v;\n}\n\nvec2 bassDrop1(float time)\n{\n    // Groovy four-bar phrase of the bass during the drop.\n    \n    // (In fact, it is the only part of this song with\n    // some melodic/rhythmic complexity and variation.\n    // The rest is extremely mechanical.)\n    \n    vec2 v = vec2(0);\n    \n    time = mod(time, 8.);\n    \n    float sx = floor(time / 0.125); // sixteenth note number\n    float st = mod(time, 0.125);\n    bool isShort = true; // True for 16th note, false for 8th note\n    vec2 nn = vec2(0.,0.); // note number, trigger short note\n    nn = (sx == 0. || sx == 5. || sx==8.) ? vec2(33,1) : \n         (sx == 2.) ? vec2(48,1) :\n         (sx == 3.) ? vec2(45,1) :\n         (sx == 14.) ? vec2(35,1) :\n         (sx == 15. || sx == 35.) ? vec2(36,1) :\n         (sx == 16. || sx == 21. || sx == 24. || sx == 30. || sx == 31.) ? vec2(26,1) :\n         (sx == 18.) ? vec2(41,1) :\n         (sx == 19.) ? vec2(38,1) :\n         (sx == 32. || sx == 37. || sx == 38. || sx == 40.) ? vec2(24,1) :\n         (sx == 34.) ? vec2(40,1) :\n         (sx == 46.) ? vec2(28,1) :\n         (sx == 47.) ? vec2(29,1) :\n         (sx == 48. || sx == 53. || sx == 54. || sx == 56. || sx == 57.) ? vec2(31,1) :\n         (sx == 50.) ? vec2(47,1) :\n         (sx == 51. || sx == 58.) ? vec2(43,1) :\n         (sx == 60. || sx == 61.) ? vec2(32,1) :\n         (sx == 62.) ? vec2(44,1) :\n         vec2(0,0);\n    \n    \n    if(sx == 30. || sx == 56. || sx == 60.)\n    { // First half of 8th notes\n        isShort = false;\n    }\n    if(sx == 31. || sx == 57. || sx == 61.)\n    {  // Second half of 8th notes\n        st += 0.125;\n        isShort = false;\n    }\n    \n    \n    float fc = 400. + 50.*sin(TAU*time);\n    v += bass1(st, midicps(nn.x), fc) * nn.y;\n    \n    // Decay end of note to avoid clicks\n    if(isShort) v *= smoothstep(0.125,0.12,st);\n    else v *= smoothstep(0.125,0.12,st-0.125);\n    \n    return v;\n}\n\nvec2 padDrop1(float time, float fres)\n{\n    // Pad part for the drop : uses pad2 (the phase-modulation based pad)\n    vec2 v = vec2(0);\n    \n    float t = mod(time, 8.);\n    // Very sparse choice of notes.\n    // Chord transitions happen after the start of the bar.\n    vec4 chord = (t < 2.75) ? vec4(69,72,69,72) : \n    (t < 4.75) ? vec4(69,72,69,74) : (t < 6.75) ? vec4(69,72,67,72) : vec4(69,72,69,71);\n    // Funky automation to avoid boredom\n    float env = (0.05 + window(0.,4.,t) + window(4.,8.,t)) * exp(-5.*mod(-t, 0.25));\n    v += pad2(time, midicps(chord), fres) * env;\n    \n    return v;\n}\n\nvec2 fullDrop1(float time)\n{\n    // Full mix of the bass drop.\n    vec2 v = vec2(0);\n    float t = mod(time, 0.5);\n    // Fake sidechain compression again\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\n    // Hi-hat timbre rises from "dull" to "harsh"\n    float fhat = 5000. + 3000.*smoothstep(24.,32.,time);\n    \n    v += bassDrop1(time) * mix(pumping, 1., 0.8);\n    v += kick1(mod(time, 0.5) + 0.008);\n    \n    v += padDrop1(time, 8000.) * mix(pumping, 1., 0.05);\n    \n    if(time > 8.)\n    {\n        // Snare comes in after 4 bars.\n        v += snare2(mod(time-0.5, 1.));\n    }\n    if(time > 16.)\n    {\n        // Hi-hat comes in after 8 bars\n        // Short hi-hat sound with fast attack and decay. Slight swing.\n        v += hat2(mod(time, 0.25), fhat) * vec2(0.8,1.0) * 0.7;\n        v += hat2(mod(time-0.14, 0.25), fhat) * vec2(0.3,-0.2) * 0.7;\n    }\n    return v;\n}\n\nvec2 fermata1(float time)\n{\n    // 2-bar fermata after verse\n    vec2 v = vec2(0);\n    // Let the last marimba note decay\n    v += marimba1(time, midicps(69.));\n    // Let the pad go from bright to dark\n    float fc = 10000. * exp(-5.*smoothstep(0.,4.,time));\n    v += pad1(time, midicps(vec4(57,60,62,64)), fc, 2.) * smoothstep(0.,0.1,time) * smoothstep(4.,0.,time);\n    \n    // Riser before drop:\n    // Lots of low-frequency noise + a bit of high-frequency\n    vec2 noise = (coloredNoise2(time, 250., 250.) + 0.1*coloredNoise2(time, 8000., 2000.)) * 0.2 * exp(-6.*smoothstep(4.,1.,time)) * smoothstep(4.,3.99,time);\n    v += noise;\n    \n    return v;\n}\n\n\nvec2 teller1(float time)\n{\n    // 1-bar riser before chorus\n    vec2 v = vec2(0);\n    float t = mod(time, 0.5);\n    float fc = 10000.*exp(2.*(time-2.));\n    // Noise riser\n    vec2 riser = coloredNoise2(time, fc*0.3, fc*0.3);\n    v += riser * smoothstep(0.,2.,time) * 0.3 * exp((time-2.)*3.);\n    // Announce the "middle A" played by the lead synth on the chorus\n    vec2 teller = pad1(time, midicps(vec4(69)), fc, 2.);\n    v += teller;\n    return v;\n}\n\n\nvec2 verseTeller(float time)\n{\n    // Pre-announce the first note played by the marimba.\n    float fC5 = midicps(72.);\n    return (sin(TAU*(fC5+vec2(-2,2))*time) + 0.5*sin(TAU*(fC5+vec2(3,-3))*time)) * 0.1 * exp(-5.*(2.-time));\n    \n}\n\nvec2 fullSong(float time)\n{\n    // Combine all parts of the song into a structured whole.\n    \n    vec2 v = vec2(0);\n    \n    if(0.<time && time < 2.)\n    {\n        v += verseTeller(time);\n    }\n    \n    time -= 2.;\n    \n    if(0. < time && time < 32.)\n    {\n        v += fullVerse(time);\n    }\n        \n    time -= 32.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += padVerse(time, 10000.) * smoothstep(0.5,0.,time);\n        v += fermata1(time);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time && time < 32.)\n    {\n        v += fullDrop1(time);\n    }\n    \n    time -= 32.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += bass1(time, midicps(33.), 400.);\n        v += pad2(time, midicps(vec4(69,71,69,72)), 8000.) * (0.5 + 0.3*cos(2.*TAU*time)) \n             * smoothstep(0.,0.5,time) * smoothstep(4.,0.,time);\n        v += verseTeller(time-2.);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time && time < 16.)\n    {\n        v += fullVerse(time+16.);\n    }\n    \n    time -= 16.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += fermata1(time);\n        v += teller1(time-2.) * smoothstep(2.,4.,time);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time)\n    {\n        v += fullChorus(time) * smoothstep(48.,32.,time); // fade out on chorus\n    }\n    \n    return v;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v = vec2(0);\n    v = fullSong(time);\n    \n    //v = fullChorus(time - 20., 10000.);\n    //v = vec2(kick1(mod(time, 0.5)));\n    \n    //v = fullDrop1(time);\n    \n    //v = fermata1(time);\n    \n    // Avoid clicks at the beginning\n    return v * smoothstep(0.,0.01,time);\n}\n'}},c={};function f(e){if(c[e])return c[e].exports;var n=c[e]={exports:{}};return s[e](n,n.exports,f),n.exports}f.d=(e,n)=>{for(var t in n)f.o(n,t)&&!f.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},f.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),e=function(){},n=function(n,t,o,a,r,i,s,c,f,l,m,v){var u=this;this.init=function(){u.timeLength=n,u.isPlaying=!0,u.needsUpdate=!1,u.time=0,u.debugFrameNumber=-1,u.uniformArray=[],u.uniforms={};var d=u.audioContext=new window.AudioContext,p=u.canvas=document.createElement("canvas");p.width=window.innerWidth,p.height=window.innerHeight,window.document.body.appendChild(p);var h=p.getContext("webgl2",{preserveDrawingBuffer:!0});if(h)if(h.getExtension("EXT_color_buffer_float"))if(h.getExtension("OES_texture_float_linear")){h.enable(h.CULL_FACE);var g=[[1,1],[-1,1],[1,-1],[-1,-1]],x=new Float32Array([].concat.apply([],g)),b=h.createBuffer();h.bindBuffer(h.ARRAY_BUFFER,b),h.bufferData(h.ARRAY_BUFFER,x,h.STATIC_DRAW),h.bindBuffer(h.ARRAY_BUFFER,null);var y=[[0,1,2],[3,2,1]],T=new Uint16Array([].concat.apply([],y)),w=h.createBuffer();h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,w),h.bufferData(h.ELEMENT_ARRAY_BUFFER,T,h.STATIC_DRAW),h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,null);var E=h.createVertexArray(),A=[],R=v(h),S=(o.split("\n").length,function(e,n){var t=h.createShader(n);if(h.shaderSource(t,e),h.compileShader(t),!h.getShaderParameter(t,h.COMPILE_STATUS)){var o=h.getShaderInfoLog(t);console.log(e,o)}return t}),C=function(e){var n=[S(t,h.VERTEX_SHADER),S(e,h.FRAGMENT_SHADER)],o=h.createProgram();return n.forEach((function(e){return h.attachShader(o,e)})),h.linkProgram(o),h.getProgramParameter(o,h.LINK_STATUS)||console.log(h.getProgramInfoLog(o)),o},U=function(e){if(1===e.type)return{frameBuffer:null,texture:null};var n=e.uniforms.iResolution.value[0],t=e.uniforms.iResolution.value[1],o=h.FLOAT,a=h.RGBA32F,r=h.LINEAR;4===e.type&&(n=512,t=512,o=h.UNSIGNED_BYTE,a=h.RGBA,r=h.NEAREST);var i=h.createFramebuffer();h.bindFramebuffer(h.FRAMEBUFFER,i);var s=h.createTexture();return h.bindTexture(h.TEXTURE_2D,s),h.texImage2D(h.TEXTURE_2D,0,a,n,t,0,h.RGBA,o,null),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MAG_FILTER,r),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_MIN_FILTER,r),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_S,h.CLAMP_TO_EDGE),h.texParameteri(h.TEXTURE_2D,h.TEXTURE_WRAP_T,h.CLAMP_TO_EDGE),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,s,0),h.bindTexture(h.TEXTURE_2D,null),h.bindRenderbuffer(h.RENDERBUFFER,null),h.bindFramebuffer(h.FRAMEBUFFER,null),{frameBuffer:i,texture:s}},_=function(n,t,o,a){!function(e){h.bindVertexArray(E),h.bindBuffer(h.ARRAY_BUFFER,b),h.bindBuffer(h.ELEMENT_ARRAY_BUFFER,w);var n=h.getAttribLocation(e,"vert2d"),t=h.FLOAT,o=g[0].length,a=o*Float32Array.BYTES_PER_ELEMENT;h.enableVertexAttribArray(n),h.vertexAttribPointer(n,o,t,!1,a,0),h.bindVertexArray(null)}(n);var s=new e;if(s.program=n,s.index=t,s.type=o,s.scale=a,s.uniforms={iResolution:{type:"v3",value:[p.width*s.scale,p.height*s.scale,0]},iTime:{type:"f",value:0},iPrevPass:{type:"t",value:Math.max(s.index-1,0)},iChannel0:{type:"t",value:s.index},iBeforeBloom:{type:"t",value:Math.max(r-1,0)},iBlockOffset:{type:"f",value:0},iSampleRate:{type:"f",value:d.sampleRate},iTextTexture:{type:"t",value:0}},3===o){var c=t-(r+i);s.uniforms.iPairBloomDown={type:"t",value:t-2*c}}return u.uniformArray.forEach((function(e){s.uniforms[e.key]={type:"number"==typeof e.initValue?"f":"v3",value:e.initValue}})),s.locations=function(e){var n={};return Object.keys(e.uniforms).forEach((function(t){n[t]=h.getUniformLocation(e.program,t)})),n}(s),s.front=U(s),s.back=U(s),s},P=function(e){h.useProgram(e.program),h.bindFramebuffer(h.FRAMEBUFFER,e.front.frameBuffer);for(var n=0,t=Object.entries(e.uniforms);n<t.length;n++){var o=t[n],a=o[0],r=o[1],i={f:h.uniform1f,v3:h.uniform3fv},s={iPrevPass:0,iBeforeBloom:1,iPairBloomDown:2,iTextTexture:3,iChannel0:4};"t"===r.type?(h.activeTexture(h.TEXTURE0+s[a]),"iTextTexture"===a?h.bindTexture(h.TEXTURE_2D,R):h.bindTexture(h.TEXTURE_2D,A[r.value].back.texture),h.uniform1i(e.locations[a],s[a])):i[r.type].call(h,e.locations[a],r.value)}h.bindVertexArray(E);var c=0*y[0].length;h.drawElements(h.TRIANGLES,T.length,h.UNSIGNED_SHORT,c);var f=h.getError();f!==h.NO_ERROR&&console.log(f),h.bindVertexArray(null),h.useProgram(null);var l=e.front;e.front=e.back,e.back=l};u.setSize=function(e,n){var t=h.canvas;t.width=e,t.height=n,h.viewport(0,0,e,n),A.forEach((function(t){h.deleteFramebuffer(t.front.frameBuffer),h.deleteFramebuffer(t.back.frameBuffer),h.deleteTexture(t.front.texture),h.deleteTexture(t.back.texture),t.uniforms.iResolution.value=[e*t.scale,n*t.scale,0],t.front=U(t),t.back=U(t)}))},u.playSound=function(){u.audioSource.start(u.audioContext.currentTime,u.time%u.timeLength)},u.render=function(){A.forEach((function(e){e.uniforms.iTime.value=u.time;for(var n=0,t=Object.entries(u.uniforms);n<t.length;n++){var o=t[n],a=o[0],r=o[1];void 0!==e.uniforms[a]&&(e.uniforms[a].value="number"==typeof r?r:[r[0]/255,r[1]/255,r[2]/255])}P(e)}))};var B=function(e){for(var n,t=/uniform (float|vec3) (g.+);\s*(\/\/ ([\-\d\.-]+))?( ([\-\d\.]+) ([\-\d\.]+))?( [\w\d]+)?/g;null!==(n=t.exec(e));){var o;o="float"===n[1]?{key:n[2],initValue:void 0!==n[4]?parseFloat(n[4]):0}:{key:n[2],initValue:[parseFloat(n[4]),parseFloat(n[6]),parseFloat(n[7])]},u.uniforms[o.key]||(u.uniformArray.push(o),u.uniforms[o.key]=o.initValue)}};B(o),a.forEach((function(e){B(e)})),B(s),B(c),B(f),B(l);var F=0;a.forEach((function(e,n,t){if(n===r){A.push(_(C(o+s),F,2,1)),F++;for(var a=1,m=0;m<i;m++)a*=.5,A.push(_(C(o+c),F,2,a)),F++;for(m=0;m<i-1;m++)a*=2,A.push(_(C(o+f),F,3,a)),F++;A.push(_(C(o+l),F,3,1)),F++}A.push(_(C(o+e),F,n<t.length-1?0:1,1)),F++})),function(){for(var e=Math.ceil(d.sampleRate*n),t=d.createBuffer(2,e,d.sampleRate),o=262144,a=e/o,r=C(m),i=_(r,0,4,1),s=0;s<a;s++){i.uniforms.iBlockOffset.value=s*o/d.sampleRate,P(i);var c=new Uint8Array(1048576);h.readPixels(0,0,512,512,h.RGBA,h.UNSIGNED_BYTE,c);for(var f=t.getChannelData(0),l=t.getChannelData(1),v=0;v<o;v++)f[s*o+v]=(c[4*v+0]+256*c[4*v+1])/65535*2-1,l[s*o+v]=(c[4*v+2]+256*c[4*v+3])/65535*2-1}u.audioSource=d.createBufferSource(),u.audioSource.buffer=t,u.audioSource.loop=!0,u.audioSource.connect(d.destination)}();var D=0,L=null,k=function(e){requestAnimationFrame(k),L||(L=e);var n=.001*(e-D);(u.isPlaying||u.needsUpdate)&&(null!=u.onRender&&u.onRender(u.time,n),u.render(),u.time=.001*(e-L)),u.needsUpdate=!1,D=e};u.play=function(){requestAnimationFrame(k)}}else alert("need OES_texture_float_linear");else alert("need EXT_color_buffer_float");else console.log("WebGL 2 is not supported...")}},t=function(e,n,t){return e*(1-t)+n*t},o=function(e,n){return Math.sin(e+n)+.5*Math.sin(2*e+n)+.25*Math.sin(4*e+n)},a=function(){function e(e,n,t){this.x=e,this.y=n,this.z=t}return e.prototype.add=function(n){return new e(this.x+n.x,this.y+n.y,this.z+n.z)},e.prototype.mul=function(n){return new e(this.x*n.x,this.y*n.y,this.z*n.z)},e.prototype.scale=function(n){return new e(this.x*n,this.y*n,this.z*n)},e.mix=function(n,o,a){return new e(t(n.x,o.x,a),t(n.y,o.y,a),t(n.z,o.z,a))},e.fbm=function(n){return new e(o(11431,n),o(23123,n),o(87034,n))},e}(),r=new n(60,f(21).Z,f(696).Z,[f(681).Z,f(905).Z],-1,5,f(222).Z,f(370).Z,f(775).Z,f(526).Z,f(405).Z,(function(e){var n=document.createElement("canvas"),t=n.getContext("2d"),o=["A 64K INTRO","GRAPHICS","gam0022","MUSIC","sadakkey","RE: SIMULATED","REALITY","MERCURY","RGBA & TBC","Ctrl-Alt-Test","Conspiracy","Poo-Brain","Fairlight","kaneta","FMS_Cat",String.fromCharCode(189)+"-bit Cheese","Prismbeings","0x4015 & YET1","LJ & Alcatraz","logicoma","Polarity"];n.width=2048,n.height=4096,t.clearRect(0,0,n.width,n.height),t.fillStyle="black",t.fillRect(0,0,n.width,n.height),t.font="110px arial",t.textAlign="center",t.textBaseline="middle",t.fillStyle="white",o.forEach((function(e,o){t.fillText(e,n.width/2,64+128*o)}));var a=e.createTexture();return e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),a})),i=function(){function e(e){this.input=e,this.begin=0,this.done=!1}return e.prototype.then=function(e,n){return this.done||this.input<this.begin?this:this.input>=this.begin+e?(this.begin+=e,this):(n(this.input-this.begin),this.done=!0,this)},e.prototype.over=function(e){return this.done||(e(this.input-this.begin),this.done=!0),this},e}(),window.addEventListener("load",(function(){var e=!1,n=document.createElement("style");n.innerText=f(434).Z,document.head.appendChild(n),document.addEventListener("fullscreenchange",(function(){document.body.style.cursor=window.document.fullscreenElement?"none":"auto"}));var t=document.createElement("div");t.className="container",document.body.appendChild(t);var o=document.createElement("p");o.innerHTML="RESOLUTION: ",t.appendChild(o);var s=document.createElement("select");s.innerHTML='\n    <option value="0.25">LOW 25%</option>\n    <option value="0.5">REGULAR 50%</option>\n    <option value="0.75">REGULAR 75%</option>\n    <option value="1.0" selected>FULL 100%</option>\n    ',o.appendChild(s);var c=document.createElement("p");t.appendChild(c),c.innerHTML="CLICK TO START",c.className="button",c.onclick=function(){c.remove(),o.remove();var n=document.createElement("p");n.innerHTML='LOADING <div class="lds-facebook"><div></div><div></div><div></div></div>',t.appendChild(n);var f=document.createElement("p");f.innerHTML="It takes about one minute. Please wait.",f.style.fontSize="50px",t.appendChild(f),document.body.requestFullscreen().then((function(){setTimeout((function(){r.onRender=function(n){!function(e,n,t){var o=128*e/60,s=new a(0,0,10),c=new a(0,0,0);r.uniformArray.forEach((function(e){r.uniforms[e.key]=e.initValue})),new i(o%128).then(16,(function(e){s=new a(-4.379722982532216-.1*e,2.7148724854688524,-.28991836612215305).add(a.fbm(e).scale(.01)),c=new a(-.5453302285259057,2.2577012315588685,.49141768491439874),r.uniforms.gCameraFov=44,r.uniforms.gDirectionalLightX=.2+.05*e,r.uniforms.gDirectionalLightY=.59,r.uniforms.gDirectionalLightZ=.32,r.uniforms.gFogDensity=.06,r.uniforms.gMandelboxScale=2.88621239103946,r.uniforms.gSceneEps=7e-4})).over((function(){})),r.uniforms.gCameraEyeX=s.x,r.uniforms.gCameraEyeY=s.y,r.uniforms.gCameraEyeZ=s.z,r.uniforms.gCameraTargetX=c.x,r.uniforms.gCameraTargetY=c.y,r.uniforms.gCameraTargetZ=c.z}(n),!e&&n>r.timeLength+2&&(document.exitFullscreen(),e=!0)},r.init(),t.remove();var n=function(){var e=parseFloat(s.value);r.setSize(window.innerWidth*e,window.innerHeight*e)};window.addEventListener("resize",n),n(),setTimeout((function(){r.play(),r.playSound()}),2500)}),1e3)}))}}),!1)})();